<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>jdk8新特性之九Base64</title>
    <url>/java/e9dc4b97.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>Java 8 内置了 Base64 编码的编码器和解码器，Base64编码已经成为Java类库的标准。<br>Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：</p>
<ul>
<li>基本：输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。</li>
<li>URL：输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。</li>
<li>MIME：输出隐射到MIME友好格式。输出每行不超过76字符，并且使用“\n’作为分割。编码输出最后没有行分割。</li>
</ul>
</blockquote>
<a id="more"></a>

<h3 id="内嵌类"><a href="#内嵌类" class="headerlink" title="内嵌类"></a>内嵌类</h3><table>
<thead>
<tr>
<th>序号</th>
<th>内嵌类 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>static class Base64.Decoder<br>该类实现一个解码器用于，使用Base64编码来解码字节数据。</td>
</tr>
<tr>
<td>2</td>
<td>static class Base64.Encoder<br>该类实现一个编码器，使用Base64编码来编码字节数据。</td>
</tr>
</tbody></table>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table>
<thead>
<tr>
<th>序号</th>
<th>方法名 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>static Base64.Decoder getDecoder()<br>返回一个 Base64.Decoder,解码使用基本型 base64 编码方案。</td>
</tr>
<tr>
<td>2</td>
<td>static Base6+4.Encoder getEncoder()<br>返回一个Base64.Encoder,编码使用基本型 base64 编码方案。</td>
</tr>
<tr>
<td>3</td>
<td>static Base64.Decoder getMimeDecoder()<br>返回一个 Base64.Decoder ，解码使用 MIME 型 base64 编码方案。</td>
</tr>
<tr>
<td>4</td>
<td>static Base64.Encoder getMimeEncoder()<br>返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案。</td>
</tr>
<tr>
<td>5</td>
<td>static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)<br>返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案，可以通过参数指定每行的长度及行的分隔符。</td>
</tr>
<tr>
<td>6</td>
<td>static Base64.Decoder getUrlDecoder()<br>返回一个 Base64.Decoder ，解码使用 URL 和文件名安全型 base64 编码方案。</td>
</tr>
<tr>
<td>7</td>
<td>static Base64.Encoder getUrlEncoder()<br>返回一个 Base64.Encoder ，编码使用 URL 和文件名安全型 base64 编码方案。</td>
</tr>
</tbody></table>
<h3 id="Base64-实例"><a href="#Base64-实例" class="headerlink" title="Base64 实例"></a>Base64 实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.adanblog.demo;</span><br><span class="line"></span><br><span class="line">import java.io.UnsupportedEncodingException;</span><br><span class="line">import java.util.Base64;</span><br><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">public class Base64Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String str = &quot;我的？啊啊runoob?java8&quot;;</span><br><span class="line">		try &#123;</span><br><span class="line">			// 使用基本编码</span><br><span class="line">			String base64encodedString = Base64.getEncoder().encodeToString(str.getBytes(&quot;utf-8&quot;));</span><br><span class="line">			System.out.println(&quot;Base64 编码字符串 (基本) :&quot; + base64encodedString);</span><br><span class="line">			// 解码</span><br><span class="line">			byte[] bytes = Base64.getDecoder().decode(base64encodedString);</span><br><span class="line">			System.out.println(&quot;原始字符串: &quot; + new String(bytes, &quot;utf-8&quot;));</span><br><span class="line"></span><br><span class="line">			// 使用URL编码</span><br><span class="line">			String base64urlencodedString = Base64.getUrlEncoder().encodeToString(str.getBytes(&quot;utf-8&quot;));</span><br><span class="line">			System.out.println(&quot;Base64 编码字符串 (url) :&quot; + base64urlencodedString);</span><br><span class="line">			// 解码</span><br><span class="line">			byte[] bytes2 = Base64.getUrlDecoder().decode(base64urlencodedString);</span><br><span class="line">			System.out.println(&quot;原始字符串: &quot; + new String(bytes2, &quot;utf-8&quot;));</span><br><span class="line"></span><br><span class="line">			StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">			for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">				stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">			&#125;</span><br><span class="line">			byte[] bytes3=stringBuilder.toString().getBytes(&quot;utf-8&quot;);</span><br><span class="line">			//使用MIME编码</span><br><span class="line">			String base64MimeEncodedString =Base64.getMimeEncoder().encodeToString(bytes3);</span><br><span class="line">			System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + base64MimeEncodedString);</span><br><span class="line">			byte[] bytes4 = Base64.getMimeDecoder().decode(base64MimeEncodedString);</span><br><span class="line">			System.out.println(&quot;原始字符串: &quot; + new String(bytes4, &quot;utf-8&quot;));</span><br><span class="line">		&#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面结果输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Base64 编码字符串 (基本) :5oiR55qE77yf5ZWK5ZWKcnVub29iP2phdmE4</span><br><span class="line">原始字符串: 我的？啊啊runoob?java8</span><br><span class="line">Base64 编码字符串 (url) :5oiR55qE77yf5ZWK5ZWKcnVub29iP2phdmE4</span><br><span class="line">原始字符串: 我的？啊啊runoob?java8</span><br><span class="line">Base64 编码字符串 (MIME) :NmFlNjBkNjEtNGEyMy00YTEzLTllOTUtM2JmODRmOWQ5ZDA3NzFiZjczZmYtM2QzOC00MGZlLThk</span><br><span class="line">YjMtZDE2MDZmNGIzODg1NTA1ODM3NDktNGM2YS00YzM2LWI2ODctYTQ5YmFlYjE3YzY0ZDRkMmI0</span><br><span class="line">N2UtOTY1MC00Yjc5LWJlOWItZTdiY2RlN2ZiMzBjYzUyNjhjODEtNWVjMi00YzE3LTg0NmMtZWVk</span><br><span class="line">MDk2ZDIxMzQ3ZDY4ZGEyNmUtODBlOC00NjhiLThhMjUtYTk5NGFjYTk3NjAxMDAyNTYyOWYtY2M3</span><br><span class="line">Yy00MzY0LWEzNWYtNGY0MWI5M2I5M2ViMTY1ODk1NjgtZjViMC00MGFjLWJkMGItMzYzMDVkNTVm</span><br><span class="line">NDgzOWExYjYyMzEtMzc5OC00MjJmLWE2YjAtZmM2MjMzMGFiOGM5MjdjOTVhNjktN2I2My00NDFj</span><br><span class="line">LWE1ZjktMjYwYjU3MGI2YTVm</span><br><span class="line">原始字符串: 6ae60d61-4a23-4a13-9e95-3bf84f9d9d0771bf73ff-3d38-40fe-8db3-d1606f4b388550583749-4c6a-4c36-b687-a49baeb17c64d4d2b47e-9650-4b79-be9b-e7bcde7fb30cc5268c81-5ec2-4c17-846c-eed096d21347d68da26e-80e8-468b-8a25-a994aca976010025629f-cc7c-4364-a35f-4f41b93b93eb16589568-f5b0-40ac-bd0b-36305d55f4839a1b6231-3798-422f-a6b0-fc62330ab8c927c95a69-7b63-441c-a5f9-260b570b6a5f</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8新特性之八日期时间API</title>
    <url>/java/2a9754bc.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>java 8通过发布新的Date-Time API进一步加强对日期与时间的处理。在旧版的java中，日期时间APi存在诸多问题。java 8引入的新的一系列API,对时间日期处理提供了更好的支持，清楚的定义了时间日期的一些概念，比如说，瞬时时间（Instant）,持续时间（duration），日期（date）,时间（time），时区（time-zone）以及时间段（Period）。同时，借鉴了Joda库的一些优点，比如将人和机器对时间日期的理解区分开的。</p>
</blockquote>
<a id="more"></a>

<h3 id="旧版日期时间API的问题"><a href="#旧版日期时间API的问题" class="headerlink" title="旧版日期时间API的问题"></a>旧版日期时间API的问题</h3><ul>
<li>非线程安全：java.uttil.Date 是非线程安全的，所有的日期类都是可变的，这是java日期类最大的问题之一。</li>
<li>设计很差：java的日期/时间类的定义并不一致，在java.util和java.sql的包中毒有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同提高的名字，这本身就是一个非常糟糕的设计。</li>
<li>时区处理麻烦：日期类并不提供国际化，没有时区支持，因此java引入了java.util.Caleandar和java.util.TimeZone类，但他们同样存在上述所有的问题。</li>
</ul>
<h3 id="新日期时间API"><a href="#新日期时间API" class="headerlink" title="新日期时间API"></a>新日期时间API</h3><p>java8在java.time包下提供了很多新的API。以下为两个比较重要的API:</p>
<ul>
<li>Local(本地)：简化了日期时间的处理，没有时区的问题。</li>
<li>Zoned(时区)：通过制定的时区处理日期时间。<br>具体的API:</li>
<li>LocalDate：存储不包含时间的日期，比如2020-01-11。可以用来存储生日，周年纪念日，入职日期等。</li>
<li>LocalTime：存储不包含日期的时间，比如11:07:03.580。<h3 id="LocalDate-日期"><a href="#LocalDate-日期" class="headerlink" title="LocalDate-日期"></a>LocalDate-日期</h3></li>
</ul>
<p>只存储年月日。格式：2020-01-11</p>
<h4 id="创建LocalDate对象"><a href="#创建LocalDate对象" class="headerlink" title="创建LocalDate对象"></a>创建LocalDate对象</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//获取当前日期</span><br><span class="line">LocalDate currDate=LocalDate.now();</span><br><span class="line">System.out.println(&quot;当前日期：&quot;+currDate);</span><br><span class="line">//指定日期</span><br><span class="line">LocalDate noeDay=LocalDate.of(2020, 1, 11);</span><br><span class="line">System.out.println(&quot;当前日期：&quot;+noeDay);</span><br><span class="line">//通过字符串指定日期</span><br><span class="line">LocalDate towDay=LocalDate.parse(&quot;2020-01-11&quot;);</span><br><span class="line">System.out.println(&quot;当前日期：&quot;+towDay);</span><br></pre></td></tr></table></figure>

<p>运行结果输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前日期：2020-01-11</span><br><span class="line">当前日期：2020-01-11</span><br><span class="line">当前日期：2020-01-11</span><br></pre></td></tr></table></figure>

<h4 id="获取年月日周"><a href="#获取年月日周" class="headerlink" title="获取年月日周"></a>获取年月日周</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 年</span><br><span class="line">int year = currDate.getYear();</span><br><span class="line">// 月</span><br><span class="line">int month = currDate.getMonthValue();</span><br><span class="line">// 一月的第几天</span><br><span class="line">int day = currDate.getDayOfMonth();</span><br><span class="line">// 一周的第几天</span><br><span class="line">int week = currDate.getDayOfWeek().getValue();</span><br><span class="line">System.out.printf(&quot;%d年%d月%d日，星期%d%n&quot;, year, month, day, week);</span><br></pre></td></tr></table></figure>

<p>运行结果输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020年1月11日，星期6</span><br></pre></td></tr></table></figure>

<h4 id="比较两个日期是否相同"><a href="#比较两个日期是否相同" class="headerlink" title="比较两个日期是否相同"></a>比较两个日期是否相同</h4><p>LocalDate重写了equals方法，让日期的比较也变得简单了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDate date1  = LocalDate.parse(&quot;2020-01-11&quot;);</span><br><span class="line">LocalDate date2  = LocalDate.parse(&quot;2020-01-11&quot;);</span><br><span class="line">System.out.println(&quot;比较两个日期是否相同：&quot;+date1.equals(date2));</span><br></pre></td></tr></table></figure>

<p>运行结果输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">比较两个日期是否相同：true</span><br></pre></td></tr></table></figure>

<h4 id="日期前后比较"><a href="#日期前后比较" class="headerlink" title="日期前后比较"></a>日期前后比较</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//isBefore在之前</span><br><span class="line">boolean isBefore=LocalDate.parse(&quot;2020-01-11&quot;).isBefore(LocalDate.parse(&quot;2020-01-10&quot;));</span><br><span class="line">//isAfter在之后</span><br><span class="line">boolean isAfter=LocalDate.parse(&quot;2020-01-11&quot;).isAfter(LocalDate.parse(&quot;2020-01-10&quot;));</span><br></pre></td></tr></table></figure>

<h4 id="日期加减"><a href="#日期加减" class="headerlink" title="日期加减"></a>日期加减</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;当前时间&quot;+LocalDate.now());</span><br><span class="line">System.out.println(&quot;当前时间加1天&quot;+LocalDate.now().plusDays(1));</span><br><span class="line">System.out.println(&quot;当前时间加1月&quot;+LocalDate.now().plusMonths(1));</span><br><span class="line">System.out.println(&quot;当前时间加1年&quot;+LocalDate.now().plusYears(1));</span><br></pre></td></tr></table></figure>

<p>运行结果输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前时间2020-01-11</span><br><span class="line">当前时间加1天2020-01-12</span><br><span class="line">当前时间加1月2020-02-11</span><br><span class="line">当前时间加1年2021-01-11</span><br></pre></td></tr></table></figure>

<h3 id="LocalTime-时间"><a href="#LocalTime-时间" class="headerlink" title="LocalTime-时间"></a>LocalTime-时间</h3><p>存储不包含日期的时间，比如11:07:03.580。</p>
<p>LocalTime和LocalDate类似，区别在于LocalDate不包含具体时间，而LocalTime包含具体时间。同样可以使用now、of或parse方法来获得对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalTime time = LocalTime.now();</span><br><span class="line">LocalTime time2 =LocalTime.of(11, 7,3);</span><br><span class="line">LocalTime time3 =LocalTime.parse(&quot;11:07:03&quot;);</span><br></pre></td></tr></table></figure>

<p>LocalDate类似它也拥有isBefore、isAfter、获取时间单元等方法，就不再赘述。</p>
<p>需要注意的是，LocalTime获得的时间格式为：11:41:58.904。也就是，HH:mm:ss.nnn，这里nnn是纳秒。</p>
<p>还有一个在实战中查询日期区间时我们经常定义的“23:59:59.99”常量再也不用自己定义了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//最大时间23:59:59.999999999</span><br><span class="line">LocalTime maxTime =LocalTime.MAX;</span><br><span class="line">//最小时间00:00</span><br><span class="line">LocalTime minTime =LocalTime.MIN;</span><br></pre></td></tr></table></figure>

<h3 id="LocalDateTime-日期和时间的组合"><a href="#LocalDateTime-日期和时间的组合" class="headerlink" title="LocalDateTime-日期和时间的组合"></a>LocalDateTime-日期和时间的组合</h3><p>LocalDateTime表示日期和时间组合。同样可以使用now、of或parse方法来获得对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDateTime datetime=LocalDateTime.now();</span><br><span class="line">LocalDateTime datetime2=LocalDateTime.of(2020, 1,11,11,54,30);</span><br><span class="line">LocalDateTime datetime3=LocalDateTime.parse(&quot;2020-01-11T12:35&quot;);</span><br></pre></td></tr></table></figure>

<p>也可以调用LocalDate的atTime()方法或LocalTime的atDate()方法将LocalDate或LocalTime合并成一个LocalDateTime。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDateTime datetime4=LocalDate.now().atTime(LocalTime.now());</span><br><span class="line">LocalDateTime datetime5=LocalTime.now().atDate(LocalDate.now());</span><br></pre></td></tr></table></figure>

<p>LocalDateTime与LocalDate和LocalTime之间可以相互转化。其他日期增减等操作与上面的类似。</p>
<h3 id="Instant-时间戳"><a href="#Instant-时间戳" class="headerlink" title="Instant-时间戳"></a>Instant-时间戳</h3><p>用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 默认获取UTC时区</span><br><span class="line">Instant instant=Instant.now();</span><br><span class="line">System.out.println(&quot;当前时间（UTC时区）:&quot;+instant);</span><br><span class="line">System.out.println(&quot;获取时间戳:&quot;+instant.toEpochMilli());</span><br><span class="line">		</span><br><span class="line">// 偏移量运算</span><br><span class="line">OffsetDateTime offsetDateTime =instant.atOffset(ZoneOffset.ofHours(8));</span><br><span class="line">System.out.println(&quot;当前时间:&quot;+offsetDateTime);</span><br><span class="line">		</span><br><span class="line">// 以Unix元年为起点，进行偏移量运算</span><br><span class="line">Instant instant2 = Instant.ofEpochSecond(60);</span><br><span class="line">System.out.println(instant2);</span><br></pre></td></tr></table></figure>

<p>运行结果输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前时间（UTC时区）:2020-01-11T05:55:35.493Z</span><br><span class="line">获取时间戳:1578722135493</span><br><span class="line">当前时间:2020-01-11T13:55:35.493+08:00</span><br><span class="line">1970-01-01T00:01:00Z</span><br></pre></td></tr></table></figure>

<h4 id="Duration-获取时间段"><a href="#Duration-获取时间段" class="headerlink" title="Duration-获取时间段"></a>Duration-获取时间段</h4><p>Duration的内部实现与Instant类似，但Duration表示时间段，通过between方法创建。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDateTime from = LocalDateTime.now();</span><br><span class="line">LocalDateTime to = LocalDateTime.now().plusDays(1);</span><br><span class="line">Duration duration=Duration.between(from, to);</span><br><span class="line">		</span><br><span class="line">//总天数</span><br><span class="line">long days=duration.toDays();</span><br><span class="line">//小时</span><br><span class="line">long hours=duration.toHours();</span><br><span class="line">//分钟</span><br><span class="line">long millis=duration.toMillis();</span><br><span class="line">//秒数</span><br><span class="line">long seconds=duration.getSeconds();</span><br><span class="line">//毫秒数</span><br><span class="line">long minutes=duration.toMinutes();</span><br><span class="line">//纳秒数</span><br><span class="line">long nanos=duration.toNanos();</span><br><span class="line">System.out.println(&quot;天数&quot;+days);</span><br><span class="line">System.out.println(&quot;小时&quot;+hours);</span><br><span class="line">System.out.println(&quot;分钟&quot;+millis);</span><br><span class="line">System.out.println(&quot;秒数&quot;+seconds);</span><br><span class="line">System.out.println(&quot;毫秒数&quot;+minutes);</span><br><span class="line">System.out.println(&quot;纳秒数&quot;+nanos);</span><br></pre></td></tr></table></figure>

<p>运行结果输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">天数1</span><br><span class="line">小时24</span><br><span class="line">分钟86400000</span><br><span class="line">秒数86400</span><br><span class="line">毫秒数1440</span><br><span class="line">纳秒数86400000000000</span><br></pre></td></tr></table></figure>

<p>Duration对象还可以通过of()方法创建，该方法参数为时间段长度和时间单位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 7天</span><br><span class="line">Duration duration1 = Duration.of(7, ChronoUnit.DAYS);</span><br><span class="line">// 60秒</span><br><span class="line">Duration duration2 = Duration.of(60, ChronoUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<h3 id="Period-获取日期段"><a href="#Period-获取日期段" class="headerlink" title="Period-获取日期段"></a>Period-获取日期段</h3><p>Period与Duration类似，获取一个时间段，只不过单位为年月日，也可以通过of方法和between方法创建，between方法接收的参数为LocalDate。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Period period=Period.of(2020, 1, 11);</span><br><span class="line">Period period1 = Period.between(LocalDate.now(), LocalDate.now().plusYears(1));</span><br></pre></td></tr></table></figure>

<h3 id="ZonedDateTime-创建时区时间"><a href="#ZonedDateTime-创建时区时间" class="headerlink" title="ZonedDateTime-创建时区时间"></a>ZonedDateTime-创建时区时间</h3><p>ZonedDateTime类，用于处理带时区的日期和时间。ZoneId表示不同的时区。大约有40不同的时区。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; allZoneIds=ZoneId.getAvailableZoneIds();</span><br></pre></td></tr></table></figure>

<p>创建时区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZoneId zoneId=ZoneId.of(&quot;Asia/Shanghai&quot;);</span><br></pre></td></tr></table></figure>

<p>把LocalDateTime转换成特定的时区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZonedDateTime zonedDateTime=ZonedDateTime.of(LocalDateTime.now(), zoneId);</span><br></pre></td></tr></table></figure>

<p>获取当前时区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//获取当前时区</span><br><span class="line">ZoneId z=ZoneId.systemDefault();</span><br></pre></td></tr></table></figure>

<p>获取日期时间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZonedDateTime dd = ZonedDateTime.now();</span><br><span class="line">ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="时间日期格式化"><a href="#时间日期格式化" class="headerlink" title="时间日期格式化"></a>时间日期格式化</h3><p>Java8对日期的格式化操作非常简单，首先看到上面的类大多都提供了parse方法，可以直接通过解析字符串得到对应的对象。</p>
<p>而日期和时间的格式化可通过LocalDateTime的format方法进行格式化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDateTime dateTime=LocalDateTime.now();</span><br><span class="line">String str=dateTime.format(DateTimeFormatter.ISO_DATE_TIME);</span><br><span class="line">System.out.println(str);</span><br><span class="line">str = dateTime.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>

<p>可以使用DateTimeFormatter预置的格式，也可以通过DateTimeFormatter.ofPattern方法来指定格式。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8新特性之七 Nashorn JavaScript</title>
    <url>/java/f4083af9.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>Nashorn 一个 javascript 引擎。 从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。与先前的Rhino实现相比，这带来了2到10倍的性能提升。</p>
</blockquote>
<a id="more"></a>

<h3 id="jjs"><a href="#jjs" class="headerlink" title="jjs"></a>jjs</h3><p>jjs是基于Nashorn引擎的命令行工具。它接受一些javaScript源码为参数，并且执行这些源代码。<br>例如，我们创建一个具有如下内容的sample.js文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&apos;Hello World!&apos;);</span><br></pre></td></tr></table></figure>

<p>打开控制台(在windows下定位到jdk/bin目录下)，输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jjs sample.js</span><br></pre></td></tr></table></figure>

<p>输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<h3 id="jjs-交互式编程"><a href="#jjs-交互式编程" class="headerlink" title="jjs 交互式编程"></a>jjs 交互式编程</h3><p>打开控制台(在windows下定位到jdk/bin目录下)，输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_162\bin&gt;jjs</span><br><span class="line">jjs&gt; print(&quot;Hello,World!&quot;)</span><br><span class="line">Hello,World!</span><br><span class="line">jjs&gt; quit()</span><br></pre></td></tr></table></figure>

<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>打开控制台(在windows下定位到jdk/bin目录下)，输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_162\bin&gt;jjs -- a b c</span><br><span class="line">jjs&gt; print(&apos;字母：&apos;+arguments.join(&quot;, &quot;))</span><br><span class="line">字母：a, b, c</span><br><span class="line">jjs&gt;</span><br></pre></td></tr></table></figure>

<h4 id="java中调用javaScript"><a href="#java中调用javaScript" class="headerlink" title="java中调用javaScript"></a>java中调用javaScript</h4><p>使用 ScriptEngineManager, JavaScript 代码可以在 Java 中执行，实例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.adanblog.demo;</span><br><span class="line"></span><br><span class="line">import javax.script.ScriptEngine;</span><br><span class="line">import javax.script.ScriptEngineManager;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * java8新特性之七Nashorn JavaScript</span><br><span class="line"> * @author www.adanblog.com</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class NashornJavaScriptTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ScriptEngineManager scriptEngineManager=new ScriptEngineManager();</span><br><span class="line">		ScriptEngine scriptEngine=scriptEngineManager.getEngineByName(&quot;nashorn&quot;);</span><br><span class="line">		String name=&quot;Runoob&quot;;</span><br><span class="line">		Integer result=null;</span><br><span class="line">		try &#123;</span><br><span class="line">			scriptEngine.eval(&quot;print(&apos;&quot; + name + &quot;&apos;)&quot;);</span><br><span class="line">			result=(Integer)scriptEngine.eval(&quot;3+3&quot;);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			System.out.println(&quot;执行脚本错误: &quot;+ e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(result.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Runoob</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-中调用-Java"><a href="#JavaScript-中调用-Java" class="headerlink" title="JavaScript 中调用 Java"></a>JavaScript 中调用 Java</h3><p>在sample.js文件中加上下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var BigDecimal = Java.type(&apos;java.math.BigDecimal&apos;);</span><br><span class="line"></span><br><span class="line">function calculate(amount, percentage) &#123;</span><br><span class="line"></span><br><span class="line">   var result = new BigDecimal(amount).multiply(</span><br><span class="line">   new BigDecimal(percentage)).divide(new BigDecimal(&quot;100&quot;), 2, BigDecimal.ROUND_HALF_EVEN);</span><br><span class="line">   </span><br><span class="line">   return result.toPlainString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = calculate(568000000000000000023,13.9);</span><br><span class="line">print(result);</span><br></pre></td></tr></table></figure>

<p>打开控制台(在windows下定位到jdk/bin目录下)，输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_162\bin&gt;jjs sample.js</span><br><span class="line">Hello World!</span><br><span class="line">78952000000000002017.94</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8新特性之六Optional类</title>
    <url>/java/5d7a94a.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>Optional 类主要解决的问题是臭名昭著的空指针异常（NullPointerException）。本质上，这是一个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空。<br>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。<br>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。<br>Optional 类的引入很好的解决空指针异常。</p>
</blockquote>
<a id="more"></a>

<h4 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h4><p>以下是一个 java.util.Optional<t> 类的声明：</t></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Optional&lt;T&gt;</span><br><span class="line">extends Object</span><br></pre></td></tr></table></figure>

<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><table>
<thead>
<tr>
<th>序号</th>
<th>方法 &amp;  描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>static <t> Optional<t> empty() <br>返回空的 Optional 实例。</t></t></td>
</tr>
<tr>
<td>2</td>
<td>boolean equals(Object obj)  <br>判断其他对象是否等于 Optional。</td>
</tr>
<tr>
<td>3</td>
<td>Optional<t> filter(Predicate&lt;? super <t> predicate) <br>如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。</t></t></td>
</tr>
<tr>
<td>4</td>
<td><u> Optional<u> flatMap(Function&lt;? super T,Optional<u>&gt; mapper) <br>如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional</u></u></u></td>
</tr>
<tr>
<td>5</td>
<td>T get() <br>如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException</td>
</tr>
<tr>
<td>6</td>
<td>int hashCode() <br>返回存在值的哈希码，如果值不存在 返回 0。</td>
</tr>
<tr>
<td>7</td>
<td>void ifPresent(Consumer&lt;? super T&gt; consumer) <br>如果值存在则使用该值调用 consumer , 否则不做任何事情。</td>
</tr>
<tr>
<td>8</td>
<td>boolean isPresent() <br>如果值存在则方法会返回true，否则返回 false。</td>
</tr>
<tr>
<td>9</td>
<td><u>Optional<u> map(Function&lt;? super T,? extends U&gt; mapper) <br>如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。</u></u></td>
</tr>
<tr>
<td>10</td>
<td>static <t> Optional<t> of(T value) <br>返回一个指定非null值的Optional。</t></t></td>
</tr>
<tr>
<td>11</td>
<td>static <t> Optional<t> ofNullable(T value) <br>如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。</t></t></td>
</tr>
<tr>
<td>12</td>
<td>T orElse(T other) <br>如果存在该值，返回值， 否则返回 other。</td>
</tr>
<tr>
<td>13</td>
<td>T orElseGet(Supplier&lt;? extends T&gt; other) <br>如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。</td>
</tr>
<tr>
<td>14</td>
<td><x extends throwable> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) <br>如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常</x></td>
</tr>
<tr>
<td>15</td>
<td>String toString() <br>返回一个Optional的非空字符串，用来调试</td>
</tr>
</tbody></table>
<h4 id="of-amp-amp-ofNullable"><a href="#of-amp-amp-ofNullable" class="headerlink" title="of &amp;&amp; ofNullable"></a>of &amp;&amp; ofNullable</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; Optional&lt;T&gt; of(T value) &#123;</span><br><span class="line">    return new Optional&lt;&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123;</span><br><span class="line">    return value == null ? empty() : of(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面源码， of 对null对象没有做任何处理，ofNullable才做了处理。所以当我们<strong>不知道传入的对象是否为null的时候</strong>，我们应该选择用 ofNullable来做处理。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    if (!isPresent())</span><br><span class="line">        return empty();</span><br><span class="line">    else &#123;</span><br><span class="line">        return Optional.ofNullable(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想获取Object里面的值的话，我们就需要用到这个map。</p>
<h4 id="Optional-实例"><a href="#Optional-实例" class="headerlink" title="Optional 实例"></a>Optional 实例</h4><p>我们可以通过以下实例来更好的了解 Optional 类的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.adanblog.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		TestVo vo=<span class="keyword">new</span> TestVo();</span><br><span class="line">		vo.setName(<span class="string">"我是测试"</span>);</span><br><span class="line">		Optional&lt;TestVo&gt; opt=Optional.ofNullable(vo);</span><br><span class="line">		String name=opt.map(v-&gt; v.getName()).get();</span><br><span class="line">		System.out.println(<span class="string">"Name是："</span>+name);</span><br><span class="line">		</span><br><span class="line">		Optional&lt;TestVo&gt; opt2=Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">		String name2=opt2.map(v-&gt; v.getName()).orElse(<span class="string">"我是null"</span>);</span><br><span class="line">		System.out.println(<span class="string">"Name2是："</span>+name2);</span><br><span class="line">		</span><br><span class="line">		Integer value1 = <span class="keyword">null</span>;</span><br><span class="line">	    Integer value2 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">	    <span class="comment">// Optional.ofNullable - 允许传递为 null 参数</span></span><br><span class="line">		Optional&lt;Integer&gt; optional1= Optional.ofNullable(value1);</span><br><span class="line">		<span class="comment">//Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException</span></span><br><span class="line">		Optional&lt;Integer&gt; optional2= Optional.of(value2);</span><br><span class="line">		System.out.println(sum(optional1,optional2));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 两个数相加</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">sum</span><span class="params">(Optional&lt;Integer&gt; a,Optional&lt;Integer&gt; b)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Optional.isPresent - 判断值是否存在</span></span><br><span class="line">		 System.out.println(<span class="string">"第一个参数值存在: "</span> + a.isPresent());</span><br><span class="line">	     System.out.println(<span class="string">"第二个参数值存在: "</span> + b.isPresent());</span><br><span class="line">	     Integer value1=a.orElse(<span class="number">0</span>);</span><br><span class="line">	     Integer value2=b.orElse(<span class="number">0</span>);</span><br><span class="line">	     <span class="keyword">return</span> value1+value2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Name是：我是测试</span><br><span class="line">Name2是：我是null</span><br><span class="line">第一个参数值存在: false</span><br><span class="line">第二个参数值存在: true</span><br><span class="line">两个数和：10</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8新特性之五Stream API</title>
    <url>/java/275cccb0.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。<br>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。<br>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。<br>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。<br>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br><span class="line">| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</span><br><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="什么是Stream"><a href="#什么是Stream" class="headerlink" title="什么是Stream?"></a>什么是Stream?</h4><p>Stream(流) 是一个来自数据源的元素队列并支持聚合操作</p>
<ul>
<li>元素是特定类型对象，形成一个队列。java中的Stream并不会存储元素，而是按需计算。</li>
<li>数据由于 流的来源。可以是集合，数组，I/O channel , 产生器generator等。</li>
<li>聚合操作 类似SQL语句一样操作，比如filter,map.reduce.find,match,sorted等。<br>和以前的Collection操作不同，Stream操作还有两个基础特征：</li>
<li>Pipelinling：中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格（fluent style）。这样做可以对操作进行优化，比如延迟执行(laziness)和短路（short-circuiting）。</li>
<li>内部迭代：以前对集合遍历读书通过iterator或者for-each的方式，显式的在集合外部进行迭代，这叫做外部迭代。Stream提供了内部迭代方式，通过访问者模式(Visitor)实现。</li>
</ul>
<h4 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h4><p>有两种生成流的方法：<br><strong>stream()</strong>-为集合创建串行流。<br><strong>parallelStream()</strong>-为集合创建并行流。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list=Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;);</span><br><span class="line">//创建串行流</span><br><span class="line">Stream&lt;String&gt; stream=list.stream();</span><br><span class="line">//创建并行流</span><br><span class="line">Stream&lt;String&gt; stream2=list.parallelStream();</span><br><span class="line">//串行流与并行流的区别：并行流简单理解就是多线程异步任务的一种实现。</span><br><span class="line">//下面看看具体实例,串行流与并行流打印输出效果：</span><br><span class="line">System.out.print(&quot;串行流:&quot;);</span><br><span class="line">stream.forEach(str-&gt; System.out.print(str));</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line">System.out.print(&quot;并行流:&quot;);</span><br><span class="line">stream2.forEach(str-&gt; System.out.print(str));</span><br></pre></td></tr></table></figure>

<p>运行输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">串行流:abcdefg</span><br><span class="line">并行流:edgfbac</span><br></pre></td></tr></table></figure>

<p>我们发现，使用parallelStream后，结果并不按照集合原有顺序输出。为了进一步证明该操作是并行的，我们打印出线程信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stream2.forEach(str-&gt; System.out.println(Thread.currentThread().getName()+&quot;-&gt;&quot;+str));</span><br></pre></td></tr></table></figure>

<p>运行输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main-&gt;e</span><br><span class="line">ForkJoinPool.commonPool-worker-1-&gt;b</span><br><span class="line">ForkJoinPool.commonPool-worker-2-&gt;g</span><br><span class="line">ForkJoinPool.commonPool-worker-1-&gt;c</span><br><span class="line">main-&gt;d</span><br><span class="line">ForkJoinPool.commonPool-worker-2-&gt;f</span><br><span class="line">ForkJoinPool.commonPool-worker-3-&gt;a</span><br></pre></td></tr></table></figure>

<p>通过例子可以确信parallelStream是利用多线程进行的，这可以很大程度简化我们使用并发操作。</p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>Stream 提供了新的方法forEach来迭代流中的每个数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用foreach输出10个随机数</span></span><br><span class="line">Random random=<span class="keyword">new</span> Random();</span><br><span class="line">System.out.println(<span class="string">"随机10个数字:"</span>);</span><br><span class="line">random.ints(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map 方法用于映射每个元素到对于的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//map代码片段</span><br><span class="line">List&lt;Integer&gt; muns=Arrays.asList(1,2,3,4,5,6,7,8,9);</span><br><span class="line">//集合元素中值*2</span><br><span class="line">muns=muns.stream().map(n-&gt; n*2).collect(Collectors.toList());</span><br><span class="line">System.out.println(&quot;使用map处理后结果:&quot;);</span><br><span class="line">muns.stream().forEach(n-&gt;System.out.println(n));</span><br></pre></td></tr></table></figure>

<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter方法用于通过设置的条件过滤出元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; muns=Arrays.asList(1,2,3,4,5,6,7,8,9);</span><br><span class="line">System.out.println(&quot;使用filter处理后结果:&quot;);</span><br><span class="line">//过滤元素大于5的数字，输出的数字是6-9</span><br><span class="line">muns.stream().filter(n -&gt; n&gt;5).forEach(n-&gt;System.out.println(n));</span><br></pre></td></tr></table></figure>

<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>limit 方法用于获取指定数量的流</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; muns=Arrays.asList(1,2,3,4,5,6,7,8,9);</span><br><span class="line">System.out.println(&quot;使用limit处理后结果:&quot;);</span><br><span class="line">///获取前5条数据</span><br><span class="line">muns.stream().limit(5).forEach(n-&gt;System.out.println(n));</span><br></pre></td></tr></table></figure>

<h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p>sorted 方法用于对流进行自然排序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; muns2=Arrays.asList(1,3,5,4,10,6,2,8,7);</span><br><span class="line">System.out.println(&quot;使用sorted把元素升序:&quot;);</span><br><span class="line">//进行自然序排序</span><br><span class="line">muns2.stream().sorted().forEach(System.out::println);</span><br><span class="line">System.out.println(&quot;使用sorted把元素逆序：&quot;);		muns2.stream().sorted(Comparator.reverseOrder()).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>也可以对集合中对象某个属性进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建实体，并且给年龄赋值</span></span><br><span class="line">TestVo vo1=<span class="keyword">new</span> TestVo();</span><br><span class="line">vo1.setAge(<span class="number">18</span>);</span><br><span class="line">	</span><br><span class="line">TestVo vo2=<span class="keyword">new</span> TestVo();</span><br><span class="line">vo2.setAge(<span class="number">15</span>);</span><br><span class="line">		</span><br><span class="line">TestVo vo3=<span class="keyword">new</span> TestVo();</span><br><span class="line">vo3.setAge(<span class="number">20</span>);</span><br><span class="line">		</span><br><span class="line">List&lt;TestVo&gt; voList=Arrays.asList(vo1,vo2,vo3);</span><br><span class="line">System.out.println(<span class="string">"对年龄进行升序："</span>);</span><br><span class="line"><span class="comment">//对年龄进行升序</span></span><br><span class="line">voList.stream().sorted(Comparator.comparing(TestVo :: getAge)).forEach(v-&gt; System.out.println(v.getAge()));</span><br><span class="line">System.out.println(<span class="string">"对年龄进行降序："</span>);</span><br><span class="line"><span class="comment">//对年龄进行降序</span></span><br><span class="line">voList.stream().sorted(Comparator.comparing(TestVo :: getAge).reversed()).forEach(v-&gt; System.out.println(v.getAge()));</span><br></pre></td></tr></table></figure>

<h4 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h4><p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors可用于返回列表或字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list3=Arrays.asList(&quot;now&quot;,&quot;store&quot;,&quot;list&quot;,&quot;&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;);</span><br><span class="line">//对集合进行为空筛选并返回集合</span><br><span class="line">List&lt;String&gt; filtered=list3.stream().filter(str -&gt; !str.isEmpty()).collect(Collectors.toList());</span><br><span class="line">System.out.println(&quot;筛选列表: &quot; + filtered);</span><br><span class="line">String strarray=list3.stream().filter(str -&gt;! str.isEmpty()).collect(Collectors.joining(&quot;,&quot;));</span><br><span class="line">System.out.println(&quot;合并字符串: &quot; + strarray);</span><br></pre></td></tr></table></figure>

<h4 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h4><p>一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">IntSummaryStatistics stats=numbers.stream().mapToInt(x -&gt; x).summaryStatistics();</span><br><span class="line">System.out.println(&quot;列表中最大的数：&quot;+stats.getMax());</span><br><span class="line">System.out.println(&quot;列表中最小的数：&quot;+stats.getMin());</span><br><span class="line">System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br></pre></td></tr></table></figure>

<h4 id="Stream-完整实例"><a href="#Stream-完整实例" class="headerlink" title="Stream 完整实例"></a>Stream 完整实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.adanblog.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.IntSummaryStatistics;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;<span class="keyword">import</span> org.omg.Messaging.SyncScopeHelper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java8新特性之五Stream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> www.adanblog.com</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;String&gt; list=Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>,<span class="string">"g"</span>);</span><br><span class="line">		<span class="comment">//创建串行流</span></span><br><span class="line">		Stream&lt;String&gt; stream=list.stream();</span><br><span class="line">		<span class="comment">//创建并行流</span></span><br><span class="line">		Stream&lt;String&gt; stream2=list.parallelStream();</span><br><span class="line">		<span class="comment">//串行流与并行流的区别：并行流简单理解就是多线程异步任务的一种实现。</span></span><br><span class="line">		<span class="comment">//下面看看具体实例,串行流与并行流打印输出效果：</span></span><br><span class="line">		System.out.print(<span class="string">"串行流:"</span>);</span><br><span class="line">		stream.forEach(str-&gt; System.out.print(str));</span><br><span class="line">		System.out.println(<span class="string">""</span>);</span><br><span class="line">		System.out.print(<span class="string">"并行流:"</span>);</span><br><span class="line">		stream2.forEach(str-&gt; System.out.print(str));</span><br><span class="line">		<span class="comment">//验证并行流</span></span><br><span class="line">		<span class="comment">//stream2.forEach(str-&gt; System.out.println(Thread.currentThread().getName()+"-&gt;"+str));</span></span><br><span class="line">		System.out.println(<span class="string">""</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//使用foreach输出10个随机数</span></span><br><span class="line">		Random random=<span class="keyword">new</span> Random();</span><br><span class="line">		System.out.println(<span class="string">"随机10个数字:"</span>);</span><br><span class="line">		random.ints(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//map代码片段</span></span><br><span class="line">		List&lt;Integer&gt; muns=Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">		<span class="comment">//集合元素中值*2</span></span><br><span class="line">		muns=muns.stream().map(n-&gt; n*<span class="number">2</span>).collect(Collectors.toList());</span><br><span class="line">		System.out.println(<span class="string">"使用map处理后结果:"</span>);</span><br><span class="line">		muns.stream().forEach(n-&gt;System.out.println(n));</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"使用filter处理后结果:"</span>);</span><br><span class="line">		<span class="comment">//过滤元素大于5的数字</span></span><br><span class="line">		muns.stream().filter(n-&gt;n&gt;<span class="number">5</span>).forEach(n-&gt;System.out.println(n));</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"使用limit处理后结果:"</span>);</span><br><span class="line">		<span class="comment">///获取前5条数据</span></span><br><span class="line">		muns.stream().limit(<span class="number">5</span>).forEach(n-&gt;System.out.println(n));</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"使用sorted把元素升序:"</span>);</span><br><span class="line">		List&lt;Integer&gt; muns2=Arrays.asList(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>);</span><br><span class="line">		<span class="comment">//进行自然序排序</span></span><br><span class="line">		muns2.stream().sorted().forEach(System.out::println);</span><br><span class="line">		System.out.println(<span class="string">"使用sorted把元素逆序："</span>);</span><br><span class="line">		muns2.stream().sorted(Comparator.reverseOrder()).forEach(System.out::println);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//创建实体，并且给年龄赋值</span></span><br><span class="line">		TestVo vo1=<span class="keyword">new</span> TestVo();</span><br><span class="line">		vo1.setAge(<span class="number">18</span>);</span><br><span class="line">	</span><br><span class="line">		TestVo vo2=<span class="keyword">new</span> TestVo();</span><br><span class="line">		vo2.setAge(<span class="number">15</span>);</span><br><span class="line">		</span><br><span class="line">		TestVo vo3=<span class="keyword">new</span> TestVo();</span><br><span class="line">		vo3.setAge(<span class="number">20</span>);</span><br><span class="line">		</span><br><span class="line">		List&lt;TestVo&gt; voList=Arrays.asList(vo1,vo2,vo3);</span><br><span class="line">		System.out.println(<span class="string">"对年龄进行升序："</span>);</span><br><span class="line">		<span class="comment">//对年龄进行升序</span></span><br><span class="line">		voList.stream().sorted(Comparator.comparing(TestVo :: getAge)).forEach(v-&gt; System.out.println(v.getAge()));</span><br><span class="line">		System.out.println(<span class="string">"对年龄进行降序："</span>);</span><br><span class="line">		<span class="comment">//对年龄进行降序</span></span><br><span class="line">		voList.stream().sorted(Comparator.comparing(TestVo :: getAge).reversed()).forEach(v-&gt; System.out.println(v.getAge()));</span><br><span class="line">	</span><br><span class="line">		List&lt;String&gt; list3=Arrays.asList(<span class="string">"now"</span>,<span class="string">"store"</span>,<span class="string">"list"</span>,<span class="string">""</span>,<span class="string">"e"</span>,<span class="string">"f"</span>,<span class="string">"g"</span>);</span><br><span class="line">		<span class="comment">//对集合进行为空筛选并返回集合</span></span><br><span class="line">		List&lt;String&gt; filtered=list3.stream().filter(str -&gt; !str.isEmpty()).collect(Collectors.toList());</span><br><span class="line">		System.out.println(<span class="string">"筛选列表: "</span> + filtered);</span><br><span class="line">		String strarray=list3.stream().filter(str -&gt;! str.isEmpty()).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">		System.out.println(<span class="string">"合并字符串: "</span> + strarray);</span><br><span class="line">		</span><br><span class="line">		List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">		IntSummaryStatistics stats=numbers.stream().mapToInt(x -&gt; x).summaryStatistics();</span><br><span class="line">		System.out.println(<span class="string">"列表中最大的数："</span>+stats.getMax());</span><br><span class="line">		System.out.println(<span class="string">"列表中最小的数："</span>+stats.getMin());</span><br><span class="line">		System.out.println(<span class="string">"所有数之和 : "</span> + stats.getSum());</span><br><span class="line">		System.out.println(<span class="string">"平均数 : "</span> + stats.getAverage());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8新特性之四默认方法</title>
    <url>/java/d2c5ce1c.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>Java 8 新增了接口的默认方法。简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。我们只需在方法名前面加个 default 关键字即可实现默认方法。</p>
</blockquote>
<a id="more"></a>

<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>默认方法语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Vehicle &#123;</span><br><span class="line">	default void print() &#123;</span><br><span class="line">		System.out.println(&quot;这是一辆汽车！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多个默认方法"><a href="#多个默认方法" class="headerlink" title="多个默认方法"></a>多个默认方法</h4><p>一个接口有默认方法，考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法，以下例子说明了这种情况的解决方案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"这是一辆汽车！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FourWheeler</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"这是一辆四轮车！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案是用 super 来调用指定接口的默认方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Vehicle</span>,<span class="title">FourWheeler</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Vehicle.<span class="keyword">super</span>.print();</span><br><span class="line">        FourWheeler.<span class="keyword">super</span>.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态默认方法"><a href="#静态默认方法" class="headerlink" title="静态默认方法"></a>静态默认方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Vehicle &#123;</span><br><span class="line">	default void print() &#123;</span><br><span class="line">		System.out.println(&quot;这是一辆汽车！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 静态方法</span><br><span class="line">	 */</span><br><span class="line">	static void blowHorn() &#123;</span><br><span class="line">		System.out.println(&quot;按喇叭！！！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Car implements Vehicle,FourWheeler&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//静态接口，直接调用</span><br><span class="line">		Vehicle.blowHorn();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8新特性之三函数式接口</title>
    <url>/java/6ea1033e.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。java8 新特性非常多，上一节介绍了Java8新特性中的方法引用，本小节继续讲解Java8的新特性之三：函数式接口用。</p>
</blockquote>
<a id="more"></a>

<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。</p>
<p>函数式接口可以用<strong>@FunctionalInterface</strong>注解标识。</p>
<p>@FunctionalInterface注解是对函数式接口的标识，他的作用是对接口进行编译级别的检查，如果一个接口使用了这个注解，但是写了两个抽象方法，会出现编译错误。</p>
<p>定义了一个函数式接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">testService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">toMessage</span><span class="params">(String mes)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TestService testService = message -&gt; System.out.println(&quot;Hello &quot; + message);</span><br><span class="line">testService.toMessage(&quot;我是测试&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="java-util-function"><a href="#java-util-function" class="headerlink" title="java.util.function"></a>java.util.function</h4><p>java.util.function 它包含了很多类，用来支持 Java的 函数式编程，该包中的函数式接口有：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>接口</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>BiConsumer&lt;T,U&gt;</td>
<td>代表了一个接受两个输入参数的操作，并且不返回任何结果</td>
</tr>
<tr>
<td>2</td>
<td>BiFunction&lt;T,U,R&gt;</td>
<td>代表了一个接受两个输入参数的方法，并且返回一个结果</td>
</tr>
<tr>
<td>3</td>
<td>BinaryOperator<t></t></td>
<td>代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果</td>
</tr>
<tr>
<td>4</td>
<td>BiPredicate&lt;T,U&gt;</td>
<td>代表了一个两个参数的boolean值方法</td>
</tr>
<tr>
<td>5</td>
<td>BooleanSupplier</td>
<td>代表了boolean值结果的提供方</td>
</tr>
<tr>
<td>6</td>
<td>Consumer<t></t></td>
<td>代表了接受一个输入参数并且无返回的操作</td>
</tr>
<tr>
<td>7</td>
<td>DoubleBinaryOperator</td>
<td>代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。</td>
</tr>
<tr>
<td>8</td>
<td>DoubleConsumer</td>
<td>代表一个接受double值参数的操作，并且不返回结果。</td>
</tr>
<tr>
<td>9</td>
<td>DoubleFunction<r></r></td>
<td>代表接受一个double值参数的方法，并且返回结果</td>
</tr>
<tr>
<td>10</td>
<td>DoublePredicate</td>
<td>代表一个拥有double值参数的boolean值方法</td>
</tr>
<tr>
<td>11</td>
<td>DoubleSupplier</td>
<td>代表一个double值结构的提供方</td>
</tr>
<tr>
<td>12</td>
<td>DoubleToIntFunction</td>
<td>接受一个double类型输入，返回一个int类型结果。</td>
</tr>
<tr>
<td>13</td>
<td>DoubleToLongFunction</td>
<td>接受一个double类型输入，返回一个long类型结果</td>
</tr>
<tr>
<td>14</td>
<td>DoubleUnaryOperator</td>
<td>接受一个参数同为类型double,返回值类型也为double 。</td>
</tr>
<tr>
<td>15</td>
<td>Function&lt;T,R&gt;</td>
<td>接受一个输入参数，返回一个结果。</td>
</tr>
<tr>
<td>16</td>
<td>IntBinaryOperator</td>
<td>接受两个参数同为类型int,返回值类型也为int 。</td>
</tr>
<tr>
<td>17</td>
<td>IntConsumer</td>
<td>接受一个int类型的输入参数，无返回值 。</td>
</tr>
<tr>
<td>18</td>
<td>IntFunction<r></r></td>
<td>接受一个int类型输入参数，返回一个结果 。</td>
</tr>
<tr>
<td>19</td>
<td>IntPredicate</td>
<td>接受一个int输入参数，返回一个布尔值的结果。</td>
</tr>
<tr>
<td>20</td>
<td>IntSupplier</td>
<td>无参数，返回一个int类型结果。</td>
</tr>
<tr>
<td>21</td>
<td>IntToDoubleFunction</td>
<td>接受一个int类型输入，返回一个double类型结果 。</td>
</tr>
<tr>
<td>22</td>
<td>IntToLongFunction</td>
<td>接受一个int类型输入，返回一个long类型结果。</td>
</tr>
<tr>
<td>23</td>
<td>IntUnaryOperator</td>
<td>接受一个参数同为类型int,返回值类型也为int 。</td>
</tr>
<tr>
<td>24</td>
<td>LongBinaryOperator</td>
<td>接受两个参数同为类型long,返回值类型也为long。</td>
</tr>
<tr>
<td>25</td>
<td>LongConsumer</td>
<td>接受一个long类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>26</td>
<td>LongFunction<r></r></td>
<td>接受一个long类型输入参数，返回一个结果。</td>
</tr>
<tr>
<td>27</td>
<td>LongPredicate</td>
<td>R接受一个long输入参数，返回一个布尔值类型结果。</td>
</tr>
<tr>
<td>28</td>
<td>LongSupplier</td>
<td>无参数，返回一个结果long类型的值。</td>
</tr>
<tr>
<td>29</td>
<td>LongToDoubleFunction</td>
<td>接受一个long类型输入，返回一个double类型结果。</td>
</tr>
<tr>
<td>30</td>
<td>LongToIntFunction</td>
<td>接受一个long类型输入，返回一个int类型结果。</td>
</tr>
<tr>
<td>31</td>
<td>LongUnaryOperator</td>
<td>接受一个参数同为类型long,返回值类型也为long。</td>
</tr>
<tr>
<td>32</td>
<td>ObjDoubleConsumer<t></t></td>
<td>接受一个object类型和一个double类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>33</td>
<td>ObjIntConsumer<t></t></td>
<td>接受一个object类型和一个int类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>34</td>
<td>ObjLongConsumer<t></t></td>
<td>接受一个object类型和一个long类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>35</td>
<td>Predicate<t></t></td>
<td>接受一个输入参数，返回一个布尔值结果。</td>
</tr>
<tr>
<td>36</td>
<td>Supplier<t></t></td>
<td>无参数，返回一个结果。</td>
</tr>
<tr>
<td>37</td>
<td>ToDoubleBiFunction&lt;T,U&gt;</td>
<td>接受两个输入参数，返回一个double类型结果</td>
</tr>
<tr>
<td>38</td>
<td>ToDoubleFunction<t></t></td>
<td>接受一个输入参数，返回一个double类型结果</td>
</tr>
<tr>
<td>39</td>
<td>ToIntBiFunction&lt;T,U&gt;</td>
<td>接受两个输入参数，返回一个int类型结果。</td>
</tr>
<tr>
<td>40</td>
<td>ToIntFunction<t></t></td>
<td>接受一个输入参数，返回一个int类型结果。</td>
</tr>
<tr>
<td>41</td>
<td>ToLongBiFunction&lt;T,U&gt;</td>
<td>接受两个输入参数，返回一个long类型结果。</td>
</tr>
<tr>
<td>42</td>
<td>ToLongFunction<t></t></td>
<td>接受一个输入参数，返回一个long类型结果。</td>
</tr>
<tr>
<td>43</td>
<td>UnaryOperator<t></t></td>
<td>接受一个参数为类型T,返回值类型也为T。</td>
</tr>
</tbody></table>
<h4 id="函数式接口实例"><a href="#函数式接口实例" class="headerlink" title="函数式接口实例"></a>函数式接口实例</h4><h5 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer<t></t></h5><p>接口唯一的抽象方法是：`void accept(T t);<br>这是一个单参数，无返回值的方法，参数是泛型类。这个接口被称为消费型接口，因为没有返回值，接口里面干了什么和调用方没什么关系。<br>这种单参数无返回值的接口我们可以这么用Lambda表达式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Consumer consumer=(par)-&gt;System.out.println(par);</span><br><span class="line">consumer.accept(&quot;我是来测试Consumer&quot;);</span><br></pre></td></tr></table></figure>

<p>输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是来测试Consumer</span><br></pre></td></tr></table></figure>

<h5 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier<t></t></h5><p>接口唯一的抽象方法是：<code>T get();</code><br>这是一个无参数，有返回值的方法，返回值类型是泛型类。这个接口被称作供给型接口。<br>这种无参数有返回值的方法我们可以这么用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//供给型接口</span></span><br><span class="line">Supplier&lt;String&gt; supplier=()-&gt; <span class="keyword">new</span> String(<span class="string">"我是来测试Supplier"</span>);</span><br><span class="line">String str=supplier.get();</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>

<p>输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是来测试Supplier</span><br></pre></td></tr></table></figure>

<h5 id="ToIntFunction"><a href="#ToIntFunction" class="headerlink" title="ToIntFunction"></a>ToIntFunction<t></t></h5><p>接口唯一的抽象方法是：<code>int applyAsInt(T value);</code><br>这是一个单参数，返回值为int的方法，参数类型是泛型类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ToIntFunction&lt;String&gt; toIntFunction=(a) -&gt; Integer.parseInt(a);</span><br><span class="line">int i=toIntFunction.applyAsInt(&quot;123&quot;);</span><br><span class="line">System.out.println(&quot;测试ToIntFunction，返回整数是：&quot;+i);</span><br></pre></td></tr></table></figure>

<p>输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试ToIntFunction，返回整数是：123</span><br></pre></td></tr></table></figure>

<h5 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate<t></t></h5><p>接口唯一的抽象方法是：<code>boolean test(java.lang.Object arg0);</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.adanblog.demo;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * java8新特性之三函数接口</span><br><span class="line"> * @author www.adanblog.com</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class FunctionTest2 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Integer&gt; list=Arrays.asList(1,2,3,4,5,6,7,8,9);</span><br><span class="line">		// Predicate&lt;Integer&gt; predicate = n -&gt; true</span><br><span class="line">	    // n 是一个参数传递到 Predicate 接口的 test 方法</span><br><span class="line">		</span><br><span class="line">	    // n 如果存在则 test 方法返回 true  </span><br><span class="line">	    System.out.println(&quot;输出所有数据:&quot;);</span><br><span class="line">	    eval(list,n -&gt; true);</span><br><span class="line">	    </span><br><span class="line"></span><br><span class="line">	    // 如果 n%2 为 0 test 方法返回 true</span><br><span class="line">	    System.out.println(&quot;输出所有偶数:&quot;);</span><br><span class="line">	    eval(list, n -&gt; n%2 == 0);</span><br><span class="line">	    </span><br><span class="line">	    //如果 n 大于 3 test 方法返回 true</span><br><span class="line">	    System.out.println(&quot;输出所有大于3的数字:&quot;);</span><br><span class="line">	    eval(list, n -&gt; n&gt;3);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void eval(List&lt;Integer&gt; list,Predicate&lt;Integer&gt; predicate) &#123;</span><br><span class="line">		for (Integer n : list) &#123;</span><br><span class="line">			if(predicate.test(n)) &#123;</span><br><span class="line">				System.out.println(n+&quot; &quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出所有数据:</span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">4 </span><br><span class="line">5 </span><br><span class="line">6 </span><br><span class="line">7 </span><br><span class="line">8 </span><br><span class="line">9 </span><br><span class="line">输出所有偶数:</span><br><span class="line">2 </span><br><span class="line">4 </span><br><span class="line">6 </span><br><span class="line">8 </span><br><span class="line">输出所有大于3的数字:</span><br><span class="line">4 </span><br><span class="line">5 </span><br><span class="line">6 </span><br><span class="line">7 </span><br><span class="line">8 </span><br><span class="line">9</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8新特性之二方法引用</title>
    <url>/java/282489d7.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。java8 新特性非常多，上一节介绍了Java8新特性中的Lambda表达式，<br>本小节继续讲解Java8的新特性之二：方法引用。<br>方法引用提供了非常有用的语法，可以直接引用已有的java类或对象的方法或构造器。方法引用其实也离不开Lambda表达式，<br>与lambda联合使用 ，方法引用可以使语言的构造更加紧凑简洁，减少冗余代码。</p>
</blockquote>
<a id="more"></a>

<h4 id="方法引用的分类"><a href="#方法引用的分类" class="headerlink" title="方法引用的分类"></a>方法引用的分类</h4><table>
<thead>
<tr>
<th>类型</th>
<th>语法</th>
<th>对应lambda表达式</th>
</tr>
</thead>
<tbody><tr>
<td>构造器引用</td>
<td>Class::new</td>
<td>(args) -&gt; new 类名(args)</td>
</tr>
<tr>
<td>静态方法引用</td>
<td>Class::static_method</td>
<td>(args) -&gt; 类名.static_method(args)</td>
</tr>
<tr>
<td>对象方法引用</td>
<td>Class::method</td>
<td>(inst,args) -&gt; 类名.method(args)</td>
</tr>
<tr>
<td>实例方法引用</td>
<td>instance::method</td>
<td>(args) -&gt; instance.method(args)</td>
</tr>
</tbody></table>
<h4 id="方法引用例子："><a href="#方法引用例子：" class="headerlink" title="方法引用例子："></a>方法引用例子：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.adanblog.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java新特性之方法引用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> www.adanblog.com</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReference</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1.构造器引用,它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：</span></span><br><span class="line">		<span class="comment">//我们使用lambda表达式来的话可以写成下面这样</span></span><br><span class="line">		<span class="comment">//Fun&lt;MethodReference&gt; fun=()-&gt; new MethodReference();</span></span><br><span class="line">		<span class="comment">//MethodReference mr=MethodReference.create(fun);</span></span><br><span class="line">		<span class="comment">//但我们可以根据简化，它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：</span></span><br><span class="line">		MethodReference mr=MethodReference.create(MethodReference :: <span class="keyword">new</span>);</span><br><span class="line">		List&lt;MethodReference&gt; list=Arrays.asList(mr);</span><br><span class="line">		<span class="comment">//2.静态方法引用：它的语法是Class::static_method，实例如下：</span></span><br><span class="line">		list.forEach(MethodReference :: collide);</span><br><span class="line">		<span class="comment">//3.对象方法引用(特定类的任意对象的方法引用)：它的语法是Class::method实例如下：</span></span><br><span class="line">		list.forEach(MethodReference :: repair);</span><br><span class="line">		<span class="comment">//4.实例方法引用(特定对象的方法引用)：它的语法是instance::method实例如下：</span></span><br><span class="line">		MethodReference mr2=MethodReference.create(MethodReference :: <span class="keyword">new</span>);</span><br><span class="line">		list.forEach( mr2::follow );</span><br><span class="line"></span><br><span class="line">		<span class="comment">//我们将 System.out::println 方法作为静态方法来引用。</span></span><br><span class="line">		List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        names.add(<span class="string">"Google"</span>);</span><br><span class="line">	    names.add(<span class="string">"Runoob"</span>);</span><br><span class="line">	    names.add(<span class="string">"Taobao"</span>);</span><br><span class="line">	    names.add(<span class="string">"Baidu"</span>);</span><br><span class="line">	    names.add(<span class="string">"Sina"</span>);</span><br><span class="line">	    names.forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fun</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodReference <span class="title">create</span><span class="params">(Fun&lt;MethodReference&gt; fun)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fun.get();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(MethodReference collided)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"Collided "</span> + collided.toString());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">final</span> MethodReference another)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Following the "</span> + another.toString());</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Repaired "</span> + <span class="keyword">this</span>.toString());</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"test "</span> +str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Collided com.adanblog.demo.MethodReference@65ab7765</span><br><span class="line">Repaired com.adanblog.demo.MethodReference@65ab7765</span><br><span class="line">Following the com.adanblog.demo.MethodReference@65ab7765</span><br><span class="line">Google</span><br><span class="line">Runoob</span><br><span class="line">Taobao</span><br><span class="line">Baidu</span><br><span class="line">Sina</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8新特性之一Lambda表达式</title>
    <url>/java/325e79dc.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。java8 新特性非常多，我们这篇主要讲述Lambda表达式。<br>Lambda表达式，也可以称为闭包，它是推动java 8 发布的最重要新特性。<br>Lambda允许把函数作为一个方法的参数，函数作为参数传递进方法中。</p>
</blockquote>
<a id="more"></a>

<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>完整的Lambda表达式由三部分组成：参数列表、箭头、声明语句；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(Type1 param1, Type2 param2, ..., TypeN paramN) -&gt; &#123; statment1; statment2; ...... return statmentM;&#125;</span><br></pre></td></tr></table></figure>

<p>以下是Lambda表达式的重要特征：</p>
<ul>
<li><p><strong>可选类型声明</strong>：不需要声明参数类型，编译器可以统一识别参数值。<br><code>(param1,param2, ..., paramN) -&gt; { statment1; statment2; ...... return statmentM;}</code></p>
</li>
<li><p><strong>可选的参数圆括号</strong>：一个参数无需定义圆括号，但多个参数需要定义圆括号。<br><code>param1 -&gt; { statment1; statment2; ...... return statmentM;}</code></p>
</li>
<li><p><strong>可选的大括号</strong>：如果主体包含了一个语句，就不需要使用大括号。<br><code>(param1,param2, ..., paramN) -&gt; statment1</code></p>
</li>
<li><p><strong>可选的返回关键字</strong>：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指明表达式返回了一个数值。<br><code>param1 -&gt; statment1</code></p>
</li>
</ul>
<h4 id="Lambda-表达式实例"><a href="#Lambda-表达式实例" class="headerlink" title="Lambda 表达式实例"></a>Lambda 表达式实例</h4><p>Lambda 表达式的简单例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1. 不需要参数,返回值为 5</span><br><span class="line">() -&gt; 5</span><br><span class="line"></span><br><span class="line">// 2. 接收一个参数(数字类型),返回其2倍的值</span><br><span class="line">x -&gt; 2 * x</span><br><span class="line"></span><br><span class="line">// 3. 接受2个参数(数字),并返回他们的差值</span><br><span class="line">(x, y) -&gt; x – y</span><br><span class="line"></span><br><span class="line">// 4. 接收2个int型整数,返回他们的和</span><br><span class="line">(int x, int y) -&gt; x + y</span><br><span class="line"></span><br><span class="line">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)</span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure>

<p>现在我们在java代码中来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.adanblog.demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lambda表达式例子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> adanblog</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1. 不需要参数,返回值为 5,() -&gt; 5</span></span><br><span class="line">		Fun1 f=()-&gt;<span class="number">5</span>;</span><br><span class="line">		System.out.println(<span class="string">"返回5："</span>+f.test());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值</span></span><br><span class="line">		Fun2 f2=x -&gt; <span class="number">2</span> * x;</span><br><span class="line">		System.out.println(<span class="string">"5 * 2 = "</span>+f2.test(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3. 接受2个参数(数字),并返回他们的差值</span></span><br><span class="line">		Fun3 f3=(x, y) -&gt; x - y;</span><br><span class="line">		System.out.println(<span class="string">"5 - 3 = "</span>+f3.test(<span class="number">5</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4. 接收2个int型整数,返回他们的和</span></span><br><span class="line">		Fun4 f4=(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y;</span><br><span class="line">		System.out.println(<span class="string">"5 + 3 = "</span>+f4.test(<span class="number">5</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)</span></span><br><span class="line">		Fun5 f5=(String s) -&gt; System.out.print(s);</span><br><span class="line">		f5.test(<span class="string">"我们是来参数lamdba"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Fun1</span> </span>&#123;</span><br><span class="line">	    <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Fun2</span> </span>&#123;</span><br><span class="line">	    <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Fun3</span> </span>&#123;</span><br><span class="line">	    <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Fun4</span> </span>&#123;</span><br><span class="line">	    <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Fun5</span> </span>&#123;</span><br><span class="line">	    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(String str)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行main方法后打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回5：5</span><br><span class="line">5 * 2 = 10</span><br><span class="line">5 - 3 = 2</span><br><span class="line">5 + 3 = 8</span><br><span class="line">我们是来参数lamdba</span><br></pre></td></tr></table></figure>

<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>Lambda表达式只能引用标记了final的外层局部变量，这就是说不能在lambda内部修改定义在域外的局部变量，否则会编译称为。<br>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.adanblog.demo;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Lambda表达式变量作用域例子</span><br><span class="line"> * @author adanblog</span><br><span class="line"> */</span><br><span class="line">public class LambdaTest2 &#123;</span><br><span class="line">	final static String salutation = &quot;Hello! &quot;;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		GreetingService gs=(mes)-&gt;System.out.println(salutation+mes);</span><br><span class="line">		gs.sayMessage(&quot;我是Lambda的测试！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	interface GreetingService &#123;</span><br><span class="line">	    void sayMessage(String message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello! 我是Lambda的测试！</span><br></pre></td></tr></table></figure>

<p>我们也可以直接在lamdba表达式中访问外层的局部变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.adanblog.demo;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Lambda表达式变量作用域例子</span><br><span class="line"> * @author adanblog</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class LambdaTest3 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int num=2;</span><br><span class="line">		Fun c=(par)-&gt;System.out.println(String.valueOf(num+par));</span><br><span class="line">		c.test(5);//输出结果为7</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	interface Fun&#123;</span><br><span class="line">		 void test(int i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）<br>在上面例子中，更改变量num的值就会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.adanblog.demo;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Lambda表达式变量作用域例子</span><br><span class="line"> * @author adanblog</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class LambdaTest3 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int num=2;</span><br><span class="line">		Fun c=(par)-&gt;System.out.println(String.valueOf(num+par));</span><br><span class="line">		c.test(5);//输出结果为7</span><br><span class="line">		//在这里更改变量值，编译就会报错：Local variable num defined in an enclosing scope must be final or effectively final</span><br><span class="line">		num=5;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	interface Fun&#123;</span><br><span class="line">		 void test(int i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在lambda表达式当中，不允许声明一个与局部变量同名的参数或者局部变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int num=2;</span><br><span class="line">Fun c=(num)-&gt;System.out.println(String.valueOf(num));//编译报错</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql备份</title>
    <url>/mysql/b0f371d5.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们线上运行的数据库，数据最重要，要是哪天不小心被删了，那你也就可以打包走人了，所以我们需要mysq数据备份措施。mysql备份有全备与增量备份两种方式</p>
<a id="more"></a>

<h3 id="全备份"><a href="#全备份" class="headerlink" title="全备份"></a>全备份</h3><p><strong><em>创建备份文件夹</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /home/mysqlback/databack/</span><br></pre></td></tr></table></figure>

<p><strong><em>编写备份脚本</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#功能说明：本功能用于全量备份</span><br><span class="line">#编写日期：2019-12-23</span><br><span class="line"></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin</span><br><span class="line">export PATH </span><br><span class="line"></span><br><span class="line">#数据库账号与密码</span><br><span class="line">dbuser=&apos;root&apos;</span><br><span class="line">dbpasswd=&apos;123456&apos;</span><br><span class="line">#需要备份的数据库，多个数据库用空格分开</span><br><span class="line">dbname=&apos;test1 test2&apos;</span><br><span class="line">#备份时间</span><br><span class="line">backtime=`date +%Y%m%d%H%M%S`</span><br><span class="line">#数据备份路径</span><br><span class="line">datapath=&apos;/home/mysqlback/databack&apos;</span><br><span class="line">logpath=&quot;$&#123;datapath&#125;/log.log&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;$(date &apos;+%Y-%m-%d %H:%M:%S&apos;),备份数据库表$&#123;dbname&#125; 开始&quot; &gt;&gt; $&#123;logpath&#125;</span><br><span class="line">#正式备份数据库</span><br><span class="line">for table in $dbname; do</span><br><span class="line">echo &quot;$(date &apos;+%Y-%m-%d %H:%M:%S&apos;),$&#123;table&#125;开始备份...&quot; &gt;&gt; $&#123;logpath&#125;</span><br><span class="line">mysqldump -u$&#123;dbuser&#125; -p$&#123;dbpasswd&#125; $&#123;table&#125; | gzip&gt; $&#123;datapath&#125;/$&#123;table&#125;-$&#123;backtime&#125;.sql.gz</span><br><span class="line">#备份成功以下操作</span><br><span class="line">if [ &quot;$?&quot; == 0 ];then</span><br><span class="line">echo &quot;$(date &apos;+%Y-%m-%d %H:%M:%S&apos;),数据库表 $&#123;table&#125; 备份成功...&quot; &gt;&gt; $&#123;logpath&#125;</span><br><span class="line">cd $datapath</span><br><span class="line">#删除30天前备份，也就是只保存30天内的备份</span><br><span class="line">find $datapath -name &quot;*.sql.gz&quot; -type f -mtime +90 -exec rm -rf &#123;&#125; \; &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">echo &quot;$(date &apos;+%Y-%m-%d %H:%M:%S&apos;)数据库表 $&#123;table&#125; 备份完成!!&quot; &gt;&gt; $&#123;logpath&#125;</span><br><span class="line">else</span><br><span class="line">#备份失败则进行以下操作</span><br><span class="line">echo &quot;$(date &apos;+%Y-%m-%d %H:%M:%S&apos;)数据库表 $&#123;table&#125; 备份失败!!&quot; &gt;&gt; $&#123;logpath&#125;</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><strong><em>创建定时任务</em></strong></p>
<p>打开定时任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/crontab</span><br></pre></td></tr></table></figure>

<p>加入定时任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#每分钟执行一次全量备份</span><br><span class="line">* * * * * /home/mysqlback/fillbackup.sh &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">#每周星期日0点执行全量备份</span><br><span class="line">0 0 * * sun /home/mysqlback/fillbackup.sh &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>执行定时任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab /etc/crontab</span><br></pre></td></tr></table></figure>

<p>查看定时任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo的永久链接之abbrlink</title>
    <url>/hexo/6962f19.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>hexo的默认永久链接是在_config.yml里的配置permalink: :year/:month/:day/:title/。这种默认配置有个很不能接受的缺点，文件名为中文，会导致url链接里面出现中文。这次我来介绍一个比较方便好用的解决方案<code>hexo-abbrlink</code>插件。</p>
</blockquote>
<a id="more"></a>

<h3 id="安装hexo-abbrlink插件"><a href="#安装hexo-abbrlink插件" class="headerlink" title="安装hexo-abbrlink插件"></a>安装hexo-abbrlink插件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>

<p>站点配置文件(_config.yml)里:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: post/:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class="line">  rep: hex    # 进制：dec(default) and hex</span><br></pre></td></tr></table></figure>

<p> 使用<code>hexo g</code> 会自动在你的文章中加上<code>abbrlink: fbf5310d</code></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>linux中安装nginx</title>
    <url>/linuxs/3cbebd87.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>Nginx 是一个很强大的高性能Web和反向代理服务，它具有很多非常优越的特性。Nginx作为负载均衡服务：Nginx 既可以在内部直接支持 Rails 和 PHP 程序对外进行服务，也可以支持作为 HTTP代理服务对外进行服务。</p>
</blockquote>
<a id="more"></a>

<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>nginx需要依赖gcc zlib zlib-devel pcre-devel openssl openssl-devel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//一键安装上面依赖</span><br><span class="line"># yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</span><br></pre></td></tr></table></figure>

<h3 id="下载nginx的tar包"><a href="#下载nginx的tar包" class="headerlink" title="下载nginx的tar包"></a>下载nginx的tar包</h3><p>Nginx下载<br>官网下载：<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//下载nginx包</span><br><span class="line"># wget http://nginx.org/download/nginx-1.16.1.tar.gz</span><br><span class="line">//解压</span><br><span class="line"># tar -xvf nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//进入nginx目录</span><br><span class="line"># cd nginx-1.16.1</span><br><span class="line">//执行命令</span><br><span class="line"># ./configure</span><br><span class="line">//执行make命令来编译</span><br><span class="line"># make</span><br><span class="line">//执行make install命令安装</span><br><span class="line"># make install</span><br></pre></td></tr></table></figure>

<p>安装完成后，目录在：/usr/local/nginx/</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong><em>测试配置文件：</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd /usr/local/nginx/</span><br><span class="line"># ./sbin/nginx -t</span><br></pre></td></tr></table></figure>

<p><strong><em>启动命令</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//启动命令</span><br><span class="line"># ./sbin/nginx</span><br><span class="line">//停止命令</span><br><span class="line"># ./sbin/nginx -s stop</span><br><span class="line">//另外一种停止命令</span><br><span class="line"># nginx –s quit</span><br><span class="line">//重启命令</span><br><span class="line"># ./sbin/nginx -s reload</span><br></pre></td></tr></table></figure>

<p><strong><em>查看进程命令</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ps -ef | grep nginx</span><br></pre></td></tr></table></figure>

<p><strong><em>平滑重启</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># kill -HUP Nginx主进程号</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7安装mysql</title>
    <url>/mysql/d5344ff8.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>今天我来给大家介绍在linux环境中如果安装mysql,我的操作系统是centos7.5,所有下面我所有操作步骤都在centos7.5环境下完成的。</p>
</blockquote>
<a id="more"></a>

<p><strong>检查系统是否安装mysql</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># rpm -qa | grep mysql</span><br></pre></td></tr></table></figure>

<p> 如果返回空值，说明没有安装<br> 从最新版本的linux系统开始，默认的是 Mariadb而不是mysql！</p>
<p><strong>查看是否有wget命令</strong><br>在命令行中输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># wget</span><br></pre></td></tr></table></figure>

<p>如果出现 <code>未找到命令</code>,再执行下面命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum -y install wget</span><br></pre></td></tr></table></figure>

<h3 id="安装MySQL的-Yum-Repository"><a href="#安装MySQL的-Yum-Repository" class="headerlink" title="安装MySQL的 Yum Repository"></a>安装MySQL的 Yum Repository</h3><p><strong>在mysql官方找rmp文件</strong></p>
<p>到这里找到对应系统的版本，<a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum/</a><br>点击<code>Download</code>，到了下载页面有两个大的按钮，在两个按钮下找到<br><code>No thanks, just start my download.</code>右键复制链接地址。<br>黏贴后就是<a href="https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm" target="_blank" rel="noopener">https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm</a></p>
<p><strong>下载rpm文件并安装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># wget https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># rpm -Uvh mysql80-community-release-el7-1.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>接下来就可以正式安装mysql了,但是呢?如果直接安装默认的是8.0版本的,我在这里演需要安装5.7版本.如果需要的就是8.0版本可以跳过下一步</p>
<p><strong>修改安装默认为mysql5.7版本</strong><br>修改配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vi /etc/yum.repos.d/mysql-community.repo</span><br></pre></td></tr></table></figure>

<p>这里我用的是mysql5.7的所以把5.7的enabled=1,把8.0的enabled=0 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Enable to use MySQL 5.7</span><br><span class="line">[mysql57-community]</span><br><span class="line">name=MySQL 5.7 Community Server</span><br><span class="line">baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/7/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br><span class="line"></span><br><span class="line">[mysql80-community]</span><br><span class="line">name=MySQL 8.0 Community Server</span><br><span class="line">baseurl=http://repo.mysql.com/yum/mysql-8.0-community/el/7/$basearch/</span><br><span class="line">enabled=0</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br></pre></td></tr></table></figure>

<p>修改好保存退出</p>
<p><strong>安装mysql</strong><br>执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install mysql mysql-server mysql-devel</span><br></pre></td></tr></table></figure>

<p>这步可能会花些时间，安装完成后就会覆盖掉之前的mariadb</p>
<h3 id="MySQL数据库设置"><a href="#MySQL数据库设置" class="headerlink" title="MySQL数据库设置"></a>MySQL数据库设置</h3><p><strong>首先启动MySQL</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemctl start  mysqld.service</span><br></pre></td></tr></table></figure>

<p><strong>查看MySQL运行状态：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemctl status mysqld.service</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld.service - MySQL Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Wed 2019-12-11 09:31:06 CST; 10s ago</span><br><span class="line">     Docs: man:mysqld(8)</span><br><span class="line">           http://dev.mysql.com/doc/refman/en/using-systemd.html</span><br><span class="line">  Process: 2712 ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid $MYSQLD_OPTS (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 2662 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 2715 (mysqld)</span><br><span class="line">   CGroup: /system.slice/mysqld.service</span><br><span class="line">           └─2715 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid</span><br></pre></td></tr></table></figure>

<blockquote>
<p>补上一个命令<br>重新启动mysql服务：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemctl restart  mysqld.service</span><br></pre></td></tr></table></figure>

<p><strong>找出mysql的登录密码</strong><br>此时MySQL已经开始正常运行，不过要想进入MySQL还得先找出此时root用户的密码，通过如下命令可以在日志文件中找出密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># grep &quot;password&quot; /var/log/mysqld.log</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-12-11T01:31:02.794484Z 1 [Note] A temporary password is generated for root@localhost: bpi+UkOPe7d/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>root@localhost: 后面的<code>bpi+UkOPe7d/</code>就是密码了。</p>
</blockquote>
<p><strong>进入数据库修改密码</strong><br>如下命令进入数据库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mysql -uroot -p</span><br></pre></td></tr></table></figure>

<p>输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库。<br>修改密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;;</span><br></pre></td></tr></table></figure>

<p>这里有个问题，新密码设置的时候如果设置的过于简单会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</span><br></pre></td></tr></table></figure>

<p>原因是因为MySQL有密码设置的规范，具体是与validate_password_policy的值有关,<br>修改密码规则(需要先给默认账户改好密码后执行才生效)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global validate_password_policy=0;</span><br><span class="line">mysql&gt; set global validate_password_length=1;</span><br></pre></td></tr></table></figure>

<p>此时密码就可以设置的很简单，例如1234之类的。到此数据库的密码设置就完成了。<br>退出mysql:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;exit;</span><br></pre></td></tr></table></figure>

<p>再登录试试修改密码是否成功：登录Mysql：<code>输入mysql -u帐号 -p密码</code> 这是登陆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mysql -uroot -p123456</span><br></pre></td></tr></table></figure>

<p>但此时还有一个问题，就是因为安装了Yum Repository，以后每次yum操作都会自动更新，需要把这个卸载掉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum -y mysql80-community-release.noarch</span><br></pre></td></tr></table></figure>

<p>此时才算真的完成了。</p>
<h3 id="检查mysql端口是否开启"><a href="#检查mysql端口是否开启" class="headerlink" title="检查mysql端口是否开启"></a>检查mysql端口是否开启</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># firewall-cmd --query-port=3306/tcp</span><br></pre></td></tr></table></figure>

<p>查看3306端口是否开启，yes表示开启，no表示未开启。还有一种情况，防火墙没有打开如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FirewallD is not running</span><br></pre></td></tr></table></figure>

<p>看需要双方开启防火墙<br>启动防火墙：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemctl start firewalld</span><br></pre></td></tr></table></figure>

<p>开机启用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemctl enable firewalld</span><br></pre></td></tr></table></figure>

<p>永久开启3306端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br></pre></td></tr></table></figure>

<p>重新载入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h3 id="mysql权限与远程连接"><a href="#mysql权限与远程连接" class="headerlink" title="mysql权限与远程连接"></a>mysql权限与远程连接</h3><p><strong>创建用户</strong><br>以root用户登录到数据库进行用户创建命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>username——将要创建的用户名；<br> host——指定该用户在哪个主机上可以登录，”localhost”指该用户只能在本地登录，不能在另外一台机器上远程登录，如果想远程登录，将”localhost”改为”%”，表示在任何一台电脑上都可以登录；也可以指定某台机器可以远程登录；<br>password——该用户的登录密码，密码可以为空，若为空则该用户可以不需要密码登录服务器。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &apos;test_admin&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;admin@123_S&apos;;</span><br></pre></td></tr></table></figure>

<p><strong>授权</strong><br>以root用户登录到数据库进行授权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>privileges——用户的操作权限，如SELECT等。如果授予所有权限则使用ALL。<br> databasename——数据库名称。tablename——表名。如果要给该用户授予对所有数据库和表的相应操作权限则可用<em>表示，例如</em>.*<br> flush privileges;表示刷新权限</p>
</blockquote>
<p> 例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;test_amin&apos;@&apos;%&apos; IDENTIFIED BY &apos;admin@123_S&apos; WITH GRANT OPTION;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p><strong>撤销用户权限</strong><br>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REVOKE privilege ON databasename.tablename FROM &apos;username&apos;@&apos;host&apos;;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REVOKE SELECT ON *.* FROM &apos;test_amin&apos;@&apos;%&apos;;</span><br></pre></td></tr></table></figure>

<p><strong>删除账户及权限</strong><br>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop user &apos;username&apos;@&apos;host&apos;;</span><br></pre></td></tr></table></figure>

<p><strong>查看用户的授权</strong><br>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW GRANTS FOR &apos;username&apos;@&apos;host&apos;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware三种网络连接模式</title>
    <url>/article/73d152bb.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>我们使用VMware虚拟软件创建虚拟机的时候，会对<code>网络适配器</code>进行配置，但是它会有三种网络连接方式：桥接方式、NAT模式、仅主机模式。下面我给大家介绍一下三种网络连接的区别。</p>
</blockquote>
<a id="more"></a>

<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>桥接模式，虚拟机的虚拟网络适配器与主机的物理网络适配器进行交接，机的物理网络适配器和虚拟网络适配器就相当于<strong>处于同一个网段</strong>，虚拟机中的虚拟网络适配器可通过主机中的物理网络适配器<strong>直接访问到外部网络</strong>。可以理解成，在局域网中添加了一台新的、独立的计算机一样，<strong>虚拟机会占用局域网中的一个IP地址</strong>，并且可以和其他终端进行相互访问。</p>
<h3 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h3><p>使用NAT模式网络连接时，VMware会在主机上建立<strong>单独的专用网络</strong>，用以在主机和虚拟机之间相互通信。虚拟机向外部网络发送的请求数据”包裹”，都会交由NAT网络适配器加上”特殊标记”并以主机的名义转发出去，外部网络返回的响应数据”包裹”，也是先由主机接收，然后交由NAT网络适配器根据”特殊标记”进行识别并转发给对应的虚拟机，因此，虚拟机在外部网络中不必具有自己的IP地址。从外部网络来看，虚拟机和主机在<strong>共享一个IP地址</strong>，默认情况下，<strong>外部网络终端也无法访问到虚拟机</strong>。</p>
<p>此外，在一台主机上只允许有一个NAT模式的虚拟网络。因此，同一台主机上的多个采用NAT模式网络连接的虚拟机也是可以相互访问的。</p>
<p>前面我们已经提到，默认情况下，外部网络无法访问到虚拟机，不过我们也可以通过手动修改NAT设置实现端口转发功能，将外部网络发送到主机指定端口的数据转发到指定的虚拟机上。比如，我们在虚拟机的80端口上”建立”了一个站点，只要我们设置端口转发，将主机88端口上的数据转发给虚拟机的80端口，就可以让外部网络通过主机的88端口访问到虚拟机80端口上的站点。</p>
<h3 id="仅主机模式"><a href="#仅主机模式" class="headerlink" title="仅主机模式"></a>仅主机模式</h3><p>仅主机模式，虚拟网络是一个<strong>全封闭的网络</strong>，它唯一能够访问的就是主机。相对于NAT模式而言，仅主机模式不具备NAT功能，所以<strong>虚拟网络不能连接到Internet</strong>(在主机上安装合适的路由或代理软件，或者在Windows系统的主机上使用Internet连接共享功能，仍然可以让虚拟机连接到Internet或其他网络)。</p>
]]></content>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10查看屏保的存储位置</title>
    <url>/article/9b3abaf4.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>当我们每次看到开机美丽漂亮的屏保时，忍不住想要收藏起来。Win10屏保每天都会下载，今天我就教大家查看保存Win10屏保图片。</p>
</blockquote>
<a id="more"></a>


<h3 id="本机自带的存储位置"><a href="#本机自带的存储位置" class="headerlink" title="本机自带的存储位置"></a>本机自带的存储位置</h3><p>在C:\Windows\Web目录下</p>
<h3 id="Win10每天下载"><a href="#Win10每天下载" class="headerlink" title="Win10每天下载"></a>Win10每天下载</h3><ol>
<li><p>第一步，定位屏保所在位置<br>按<code>win+R</code>打开“运行”对话框，输入下面命令：<br><code>C:\Users\%username%\AppData\Local\Packages\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\LocalState\Assets\</code><br>现在定位到屏保存储的位置了，但里面的文件不是图片格式，我们还需要转换格式</p>
</li>
<li><p>第二步，把临时文件修改成图片格式<br>按<code>win+R</code>打开“运行”对话框 输入cmd命令进入<br>再执行下面命令：<br><code>Ren C:\Users\%username%\AppData\Local\Packages\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\LocalState\Assets\*.* *.PNG</code><br>这个时候，你会发现屏保文件都变成了png图片格式的了，可以美美的进行收藏了。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>电脑技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows中搜索目录下所有文件包含某个字符串</title>
    <url>/article/9d31d1a2.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>在windows环境下，我要在某个文件夹内搜索包含某个字符串的文件，那么可以用<code>findstr /s /i &quot;string&quot; *.*</code></p>
</blockquote>
<a id="more"></a>
<p>在windows环境下，在某个文件夹搜索包含某个字符串的文件。<br><code>findstr /s /i &quot;string&quot; *.*</code><br><code>*.*</code>表示所有类型的文件。<br><code>/s</code> 表示当前目录以及所有子目录<br><code>/i</code> 表示不区分大小写</p>
]]></content>
      <tags>
        <tag>电脑技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo的next主题美化</title>
    <url>/hexo/fbf5310d.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>之前我介绍了hexo的搭建，这次来看看hexo的NexT主题的一些常用的优化。</p>
</blockquote>
<a id="more"></a>
<h3 id="开启版权"><a href="#开启版权" class="headerlink" title="开启版权"></a>开启版权</h3><p>配置文件<code>_config.yml</code>中将<code>post_copyright</code>下的<code>enable</code>设为<code>true</code>，即可开启版权声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_copyright:</span><br><span class="line">  enable: true</span><br><span class="line">  license: CC BY-NC-SA 3.0</span><br><span class="line">  license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/</span><br></pre></td></tr></table></figure>

<p>注意：最新版本好像不支持了</p>
<h3 id="修改文章标签样式"><a href="#修改文章标签样式" class="headerlink" title="修改文章标签样式"></a>修改文章标签样式</h3><p>标签样式默认为#tag，我们可以将其改成带图标的<br>在<code>\themes\next\layout\_macro\post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 <code>#</code> 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<h3 id="首页文章显示标签"><a href="#首页文章显示标签" class="headerlink" title="首页文章显示标签"></a>首页文章显示标签</h3><p>在 <code>\themes\next\layout\_macro\post.swig</code> 搜索 <code>post.tags and post.tags.length</code>找到代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if post.tags and post.tags.length and not is_index %&#125;</span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-tags"</span>&gt;</span></span><br><span class="line">      &#123;% for tag in post.tags %&#125;</span><br><span class="line">         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(tag.path) &#125;&#125;"</span> <span class="attr">rel</span>=<span class="string">"tag"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-tag"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> &#123;&#123; tag.name &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      &#123;% endfor %&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>把<code>and not is_index</code>去掉<br>修改后：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if post.tags and post.tags.length %&#125;</span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-tags"</span>&gt;</span></span><br><span class="line">      &#123;% for tag in post.tags %&#125;</span><br><span class="line">         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(tag.path) &#125;&#125;"</span> <span class="attr">rel</span>=<span class="string">"tag"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-tag"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> &#123;&#123; tag.name &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      &#123;% endfor %&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="博客网站图标"><a href="#博客网站图标" class="headerlink" title="博客网站图标"></a>博客网站图标</h3><p>我们博客的默认图标是H，不过我们可以修改图标。<br>制作两张图片，一张16x16，一张32x32，放到\source\images中。然后看下面代码，对应设置small与medium就行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16.png</span><br><span class="line">  medium: /images/favicon-32x32.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  #android_manifest: /images/manifest.json</span><br><span class="line">  #ms_browserconfig: /images/browserconfig.xml</span><br></pre></td></tr></table></figure>

<h3 id="作者头像设置"><a href="#作者头像设置" class="headerlink" title="作者头像设置"></a>作者头像设置</h3><p>我们设置的头像默认是方形，但可以设置头像为圆形<br>打开<code>\themes\next\source\css\_common\components\sidebar\sidebar-author.styl</code>文件<br>在site-author-image样式中加上<code>border-radius: 100px</code>如下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: $site-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: $site-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: $site-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好像新版本可以直接在配置文件中设置，我找了半天没有，就直接改样式了。现在贴出新版的代码出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  url: /images/author.jpg  #头像图片</span><br><span class="line">  rounded: true #鼠标放在头像上时是否旋转</span><br><span class="line">  opacity: 1 #头像放缩指数</span><br><span class="line">  rotated: true #头像是否设为圆形，默认为矩形</span><br></pre></td></tr></table></figure>

<h3 id="开启首页文章显示摘要"><a href="#开启首页文章显示摘要" class="headerlink" title="开启首页文章显示摘要"></a>开启首页文章显示摘要</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#选取博客正文&lt;!--more--&gt;前的内容</span><br><span class="line">scroll_to_more: true </span><br><span class="line"></span><br><span class="line"># Automatically saving scroll position on each post/page in cookies.</span><br><span class="line">save_scroll: false</span><br><span class="line"></span><br><span class="line">#自动截取摘要</span><br><span class="line">excerpt_description: true </span><br><span class="line"></span><br><span class="line">#自动截取一定程度的摘要</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: true </span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>

<h3 id="添加「分类」页面"><a href="#添加「分类」页面" class="headerlink" title="添加「分类」页面"></a>添加「分类」页面</h3><p>创建页面：<code>$ hexo new page categories</code><br>编辑刚新建的页面，将页面的 type 设置为 categories ，主题将自动为这个页面显示分类。页面内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果有集成评论服务，页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false。<br>如果页面标题出现乱码，把文件另存为utf-8格式</p>
</blockquote>
<h3 id="添加「标签」页面"><a href="#添加「标签」页面" class="headerlink" title="添加「标签」页面"></a>添加「标签」页面</h3><p>创建页面：<code>$ hexo new page tags</code><br>编辑刚新建的页面，将页面的 type 设置为 tags ，主题将自动为这个页面显示分类。页面内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果有集成评论服务，页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false。<br>如果页面标题出现乱码，把文件另存为utf-8格式</p>
</blockquote>
<h3 id="开启统计功能"><a href="#开启统计功能" class="headerlink" title="开启统计功能"></a>开启统计功能</h3><p>编辑 <code>主题配置文件</code> 中的<code>busuanzi_count</code>的配置项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  # 是否开启</span><br><span class="line">  enable: true</span><br><span class="line">  # 站点访问人数统计</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: 本站访客数</span><br><span class="line">  site_uv_footer: 人次</span><br><span class="line">  # 站点访问量统计</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: 本站总访问量</span><br><span class="line">  site_pv_footer: 次</span><br><span class="line">  # 站点文章阅读量统计</span><br><span class="line">  page_pv: true</span><br><span class="line">  page_pv_header: 本文总阅读量</span><br><span class="line">  page_pv_footer: 次</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：由于不蒜子域名更换了，所以安装官网的这种配置是没有效果的。</p>
</blockquote>
<p>解决方案：<br>打开themes\next\layout_third-party\analytics\busuanzi-counter.swig<br>找到如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="文章后添加结束标语"><a href="#文章后添加结束标语" class="headerlink" title="文章后添加结束标语"></a>文章后添加结束标语</h3><p>1.在<code>themes\next\layout\_macro</code>中创建<code>post-end-tag.swig</code>文件，并在其中添加代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:22px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>2.修改<code>themes\next\layout\_macro\post.swig</code>文件，在POST BODY块最后结束标签前添加内容，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include &apos;post-end-tag.swig&apos; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>3.打开 <code>主题配置文件</code> ，添加代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure>

<h3 id="开启评论功能"><a href="#开启评论功能" class="headerlink" title="开启评论功能"></a>开启评论功能</h3><p>我使用的是valine评论系统，由于valine评论系统是基于leancloud开发的，所以我们还需要注册leancloud来支持</p>
<ol>
<li><p>获取LeanCloud的APP ID和APP Key<br>登录或注册 LeanCloud, 进入控制台后点击左下角创建应用：<br><img src="https://i.loli.net/2019/06/21/5d0c995c86fac81746.jpg" alt="评论" title="评论"><br>应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了：<br><img src="https://i.loli.net/2019/06/21/5d0c997a60baa24436.jpg" alt="appid" title="appid"></p>
</li>
<li><p>配置valine<br>编辑 <code>主题配置文件</code>,搜索valine，修改相关配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid:  APP ID # LeanCloud的APP ID</span><br><span class="line">  appkey:  APP Key # LeanCloud的APP Key</span><br><span class="line">  notify: false # 邮件提醒 , https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # 是否开启验证码</span><br><span class="line">  placeholder: 期待你的高见 # 评论提示</span><br><span class="line">  avatar: mm # 头像</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="开启本地搜索功能"><a href="#开启本地搜索功能" class="headerlink" title="开启本地搜索功能"></a>开启本地搜索功能</h3><p>1.安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>2.编辑 <code>站点配置文件</code>，新增以下内容到任意位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>3.编辑 <code>主题配置文件</code>，启用本地搜索功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ IDEA 汉化</title>
    <url>/idea/8468a2bd.html</url>
    <content><![CDATA[<p>IntelliJ IDEA是Java的专业开发人员使用最多的开发工具之一，今天我就来教大家汉化成简体中文。</p>
<ol>
<li>打开链接：<a href="https://github.com/pingfangx/jetbrains-in-chinese" target="_blank" rel="noopener">https://github.com/pingfangx/jetbrains-in-chinese</a></li>
<li>下载,点击右边按钮”cloen or download”-“download ZIP”</li>
<li>在下载的文件中找到 IntelliJIDEA 目录点击进去</li>
<li>找到你IntelliJIDEA对应的版本jar包 resources_zh_CN_IntelliJIDEA_&lt;版本&gt;.jar</li>
<li>关闭IntelliJIDEA软件</li>
<li>复制jar包到IntelliJ IDEA的安装目录下的lib子目录下</li>
<li>打开IntelliJIDEA你就会发现都是中文了</li>
</ol>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>java SPI 与 ServiceLoader</title>
    <url>/java/fb07f666.html</url>
    <content><![CDATA[<h3 id="java-SPI机制"><a href="#java-SPI机制" class="headerlink" title="java SPI机制"></a>java SPI机制</h3><p>SPI的全名为Service Provider Interface。简单来说就是通过配置文件指定接口的实现类。在java.util.ServiceLoader的文档里有比较详细的介绍。<br>我们系统里抽象的各个模块，往往有很多不同的实现方案。那么我们来看看下面这个例子你就能明白了。</p>
<h3 id="例子代码"><a href="#例子代码" class="headerlink" title="例子代码"></a>例子代码</h3><p>比如一个电视机厂商，要生产3中不同规格的电视机，小型电视机、中型电视机、大型电视机。<br>那么我们可以设计：电视机模型接口、3种不同电视机的实现类<br>模型接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shan.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * TODO 电视机模型接口</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> adan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0, 2019年11月20日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TelevisionService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 * 生产</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">production</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>电视机实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shan.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * TODO 小型电视机</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> adan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0, 2019年11月20日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallTelevisionServiceImp</span> <span class="keyword">implements</span> <span class="title">TelevisionService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">production</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"生产小型电视机"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * TODO 中型电视机</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> adan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0, 2019年11月20日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MidsizeTelevisionServiceImp</span> <span class="keyword">implements</span> <span class="title">TelevisionService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">production</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"生产中型电视机"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * TODO 大型电视机</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> adan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0, 2019年11月20日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargeTelevisionServiceImpl</span> <span class="keyword">implements</span> <span class="title">TelevisionService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">production</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"生产大型电视机"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面已经定义好了，下面我们来实现生产3种不同电视机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shan.test;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hello world!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	App app=<span class="keyword">new</span> App();</span><br><span class="line">    	app.production2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">production1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	TelevisionService small=<span class="keyword">new</span> SmallTelevisionServiceImp();</span><br><span class="line">    	small.production();</span><br><span class="line">    	TelevisionService midsize=<span class="keyword">new</span> MidsizeTelevisionServiceImp();</span><br><span class="line">    	midsize.production();</span><br><span class="line">    	TelevisionService large=<span class="keyword">new</span> LargeTelevisionServiceImpl();</span><br><span class="line">    	large.production();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印如下：<br>生产小型电视机<br>生产中型电视机<br>生产大型电视机</p>
</blockquote>
<p>这个时候，这个电视机厂商扩展业务了，要提供了代加工电视机业务，帮别人生产电视机。<br>我们要约定生产电视机的标准了，让其他厂商比较方便接入。这就是SPI<br>规定：</p>
<ol>
<li>创建接口实现</li>
<li>在resources资源目录下创建META-INF/services文件夹</li>
<li>在services文件夹中创建，以接口类全名命名的文件</li>
<li>在文件中加入接口实现类全名</li>
</ol>
<p>我们改造一下项目<br>第一步，在resources中创建META-INF/services文件夹，并在services中创建com.shan.test.TelevisionService文件<br>第二步：在com.shan.test.TelevisionService文件中写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.shan.test.LargeTelevisionServiceImpl</span><br><span class="line">com.shan.test.MidsizeTelevisionServiceImp</span><br><span class="line">com.shan.test.SmallTelevisionServiceImp</span><br></pre></td></tr></table></figure>

<p>第三步：改造代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shan.test;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hello world!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	App app=<span class="keyword">new</span> App();</span><br><span class="line">    	app.production2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//平常实现方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">production1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	TelevisionService small=<span class="keyword">new</span> SmallTelevisionServiceImp();</span><br><span class="line">    	small.production();</span><br><span class="line">    	TelevisionService midsize=<span class="keyword">new</span> MidsizeTelevisionServiceImp();</span><br><span class="line">    	midsize.production();</span><br><span class="line">    	TelevisionService large=<span class="keyword">new</span> LargeTelevisionServiceImpl();</span><br><span class="line">    	large.production();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//通过ServiceLoader来实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">production2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;TelevisionService&gt; loadedImpl = ServiceLoader.load(TelevisionService.class);</span><br><span class="line">		Iterator&lt;TelevisionService&gt; it = loadedImpl.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			TelevisionService service = it.next();</span><br><span class="line">			service.production();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行打印如下：<br>生产小型电视机<br>生产中型电视机<br>生产大型电视机</p>
</blockquote>
<p>博主，你貌似描述清楚SPI的意思，但其他厂商怎么接入呢？<br>别急，马上来实现，再次改造项目（这个时候可能需要看源码了）<br>源码地址：<a href="https://github.com/adanblog/sourceCode.git" target="_blank" rel="noopener">https://github.com/adanblog/sourceCode.git</a></p>
<p>第一步：改造项目，把原来的一个项目拆分成2两个<br>SPITestApi,把电视机模型接口TelevisionService.java移到里面。<br>SPITest项目引用SPITestApi项目。</p>
<p>第二步：新厂商需要实现我们生产电视机的接口，<br>新建项目SPITest2，引用SPITestApi项目。<br>创建电视机的实现类，现在这个厂商要生产50寸的电视机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shan.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * TODO 50寸电视机</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> adan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0, 2019年11月20日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FiftyTelevisionServiceImpl</span> <span class="keyword">implements</span> <span class="title">TelevisionService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">production</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"生产50寸电视机"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在resources中创建META-INF/services文件夹，并创建com.shan.test.TelevisionService文件<br>写入com.shan.test.FiftyTelevisionServiceImpl</p>
<p>第三步，在SPITest项目中引用SPITest2项目<br>第四步，运行SPITest项目中app类中的main方法你会神奇的发现50寸电视机也生产出来了。</p>
<blockquote>
<p>打印如下：<br>生产大型电视机<br>生产中型电视机<br>生产小型电视机<br>生产50寸电视机</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>SPI被广泛使用在第三方插件式类库的加载，最常见的如JDBC、JNDI、JCE(Java加密模块扩展)等类库。理解ServiceLoader的工作原理有助于编写扩展性良好的可插拔的类库。<br>springBoot启动也是这种思想来实现的。</p>
<h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p><a href="https://github.com/adanblog/sourceCode.git" target="_blank" rel="noopener">https://github.com/adanblog/sourceCode.git</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>springBoot java -jar xxx.jar 报 “xxx中没有主清单属性”</title>
    <url>/springBoot/d95f9e5a.html</url>
    <content><![CDATA[<h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><p>我springBoot项目多配置多环境，使用 mvn clean package -Dmaven.test.skip=true -P prod 打包后，使用java -jar xxx.jar运行 报 “xxx中没有主清单属性” 错误。</p>
<h4 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h4><p>使用eclipse对项目 右键-&gt; Run As -&gt; Maven Install 打包后，再使用java -jar xxx.jar运行就不会报错。<br>并且使用 mvn clean package -Dmaven.test.skip=true -P prod打包后，没有 xxx.jar.original 这个文件</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>在pom.xml中需要添加以下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>springBoot</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>分页计算</title>
    <url>/article/3d703873.html</url>
    <content><![CDATA[<p>pageIndex:第几页-从1开始</p>
<p>pageSize:每页多少条数</p>
<p>totalCount:总共多少条数</p>
<p>totalPage:总页数</p>
<h2 id="mysql-limit分页"><a href="#mysql-limit分页" class="headerlink" title="mysql limit分页"></a>mysql limit分页</h2><p>语法：Limit x,y。指筛选出结果的第x行后的y行。如果x不填也是可以的，默认为0<br>limit (pageIndex-1)*pageSize,pageSize</p>
<blockquote>
<p>select * from test limit 0,10<br>查询从第0行开始后的10条记录</p>
</blockquote>
<h2 id="js-对数组分页"><a href="#js-对数组分页" class="headerlink" title="js 对数组分页"></a>js 对数组分页</h2><p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pageIndex=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> pageSize=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line"><span class="keyword">var</span> totalCount=arr.length;</span><br><span class="line"><span class="keyword">var</span> totalPage=(totalCount + pageSize - <span class="number">1</span>)/pageSize;</span><br><span class="line"><span class="keyword">if</span>(pageIndex&gt;totalPage) &#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> start=(pageIndex<span class="number">-1</span>)*pageSize</span><br><span class="line"><span class="keyword">var</span> end=start+pageSize;</span><br><span class="line">end=end&gt;totalCount?totalCount:end;</span><br><span class="line">alert(arr.slice(start,end));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出:<br>4,5,6</p>
</blockquote>
<h2 id="java对数组、list分页"><a href="#java对数组、list分页" class="headerlink" title="java对数组、list分页"></a>java对数组、list分页</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr=<span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">"10"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> pageIndex=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> pageSize=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> totalCount=arr.length;</span><br><span class="line"><span class="keyword">int</span> totalPage=(totalCount + pageSize - <span class="number">1</span>)/pageSize;</span><br><span class="line">System.out.println(<span class="string">"总页数:"</span>+totalPage);</span><br><span class="line"><span class="keyword">if</span>(pageIndex&gt;totalPage) &#123;</span><br><span class="line">	<span class="comment">//java中下标越界会报错</span></span><br><span class="line">	System.out.print(<span class="string">"不能超过总页数"</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start=(pageIndex-<span class="number">1</span>)*pageSize;</span><br><span class="line"><span class="keyword">int</span> end=start+pageSize-<span class="number">1</span>;</span><br><span class="line">end=end&gt;=totalCount?totalCount-<span class="number">1</span>:end;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++) &#123;</span><br><span class="line">	System.out.print(arr[i]);</span><br><span class="line">	<span class="keyword">if</span>(i&lt;end) &#123;</span><br><span class="line">		System.out.print(<span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出:<br>总页数:4<br>7,8,9</p>
</blockquote>
]]></content>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title>js使用slice方法获取数组中某段元素</title>
    <url>/js/cce01cbb.html</url>
    <content><![CDATA[<p>slice() 方法可从已有的数组中返回选定的元素。</p>
<ul>
<li><p>语法：arrayObj.slice(start, [end])</p>
</li>
<li><p>参数：</p>
<p>  start：必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</p>
<p>  end：可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</p>
</li>
<li><p>返回值：返回一个新的Array，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</p>
</li>
</ul>
<p>列子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> newArr=arr.slice(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">document</span>.write(arr+ <span class="string">"&lt;br /&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(newArr);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line"><span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭建博客教程</title>
    <url>/hexo/a6efda57.html</url>
    <content><![CDATA[<h2 id="安装工作"><a href="#安装工作" class="headerlink" title="安装工作"></a>安装工作</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><ul>
<li><p>Windows:下载并安装 <a href="https://nodejs.org/en/" title="点击下载" target="_blank" rel="noopener">点击下载</a><br>官网地址：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p>
</li>
<li><p>Linux安装:</p>
</li>
</ul>
<p>　　cURL:<code>$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | sh</code></p>
<p>　　Wget:<code>$ wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | sh</code></p>
<p>　　安装完成后，执行命令即可安装 Node.js:<code>$ nvm install node</code></p>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><ul>
<li>Windows：下载并安装 <a href="https://git-scm.com/download/win" title="git" target="_blank" rel="noopener">git</a>.</li>
<li>Linux (Ubuntu, Debian)：<code>$　sudo apt-get install git-core</code></li>
<li>Linux (Fedora, Red Hat, CentOS)：<code>$　sudo yum install git-core</code></li>
</ul>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。<br><code>$ npm install -g hexo-cli</code></p>
<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><ol>
<li><p>初始化hexo<br>创建文件夹（myblog），然后cd到该文件夹中，然后执行下面命令：<br><code>$ hexo init</code></p>
</li>
<li><p>启动hexo<br>使用gitbash进入myblog文件夹，分别执行以下命令<br><code>$ hexo clean</code><br><code>$ hexo generate</code><br><code>$ hexo server</code><br>打开浏览器输入<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就能看到自己的博客了</p>
</li>
</ol>
<h2 id="部署到-GitHub-Pages"><a href="#部署到-GitHub-Pages" class="headerlink" title="部署到 GitHub Pages"></a>部署到 GitHub Pages</h2><ol>
<li><p>在GitHub新建一个repository。如果你希望你的站点能通过 &lt;你的 GitHub 用户名&gt;.github.io 域名访问，你的 repository 应该直接命名为 “&lt;你的 GitHub 用户名&gt;.github.io”。</p>
</li>
<li><p>安装 hexo-deployer-git<br><code>$ npm install hexo-deployer-git --save</code></p>
</li>
<li><p>更新配置<br>使用编辑器打开_config.yml文件，找到deploy配置并按下方配置（repo配置你的GitHub仓库地址）：<br>deploy:<br>　type:git<br>　repo:<a href="https://github.com/adanblog/adanblog.git" target="_blank" rel="noopener">https://github.com/adanblog/adanblog.git</a><br>　branch:master</p>
</li>
<li><p>发布到服务器<br>分布执行下面命令：<br><code>$ hexo clean</code><br><code>$ hexo generate</code><br><code>$ hexo deploy</code></p>
<blockquote>
<p>注意：发布的时候需要你输入GitHub密码。如果不想每次都输入密码，可以使用ssh进行验证。<br>本地执行：<code>$ ssh-keygen -t rsa -C &quot;xxxx@qq.com&quot;</code><br>出现id_rsa和id_rsa.pub两个文件。<br>登录Github,找到右上角的图标，打开点进里面的Settings，再选中里面的SSH and GPG KEYS，点击右上角的New SSH key，然后Title里面随便填，再把刚才id_rsa.pub里面的内容复制到Title下面的Key内容框里面，最后点击Add SSH key，这样就完成了SSH Key的加密</p>
</blockquote>
</li>
</ol>
<h2 id="配置个性化主题"><a href="#配置个性化主题" class="headerlink" title="配置个性化主题"></a>配置个性化主题</h2><ol>
<li><p>文档版本</p>
<ul>
<li>前往 NexT 版本 <a href="https://github.com/iissnan/hexo-theme-next/releases" title="发布页面" target="_blank" rel="noopener">发布页面</a>。</li>
<li>选择你所需要的版本，下载 Download 区域下的 Source Code (zip) 到本地。</li>
<li>解压所下载的压缩包至站点的 themes 目录下， 并将 解压后的文件夹名称（hexo-theme-next-0.4.0）更改为 next。 </li>
<li>打开 站点配置文件（_config.yml）， 找到 theme 字段，并将其值更改为 next<br>theme: next</li>
</ul>
</li>
<li><p>最新版<br>命令：<code>$ git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p>
</li>
<li><p>更多配置到 <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a> 查看</p>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于此博客</title>
    <url>/about/4a684914.html</url>
    <content><![CDATA[<blockquote>
<p><strong>关于阿丹博客</strong><br> 下面阿丹的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛。<br>个人博客：<a href="http://www.adanblog.com/">http://www.adanblog.com/</a><br><img src="https://adanblog.github.io/images/dibutuiguang.jpg" alt></p>
</blockquote>
]]></content>
  </entry>
</search>
